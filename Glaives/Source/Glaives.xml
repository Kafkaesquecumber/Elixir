<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Glaives</name>
    </assembly>
    <members>
        <member name="T:Glaives.Core.Actor">
            <summary>
            Base class for any object that is part of a level hierarchy and can be transformed
            </summary>
        </member>
        <member name="P:Glaives.Core.Actor.Name">
            <summary>
            The unique name of the actor
            </summary>
        </member>
        <member name="P:Glaives.Core.Actor.Children">
            <summary>
            Enumerates the children for this actor (no sub-children)
            </summary>
        </member>
        <member name="P:Glaives.Core.Actor.Parent">
            <summary>
            Parent the actor to another actor (cannot be null, use Unparent to parent the actor to the level root)
            </summary>
        </member>
        <member name="P:Glaives.Core.Actor.LocalPosition">
            <summary>
            The position in local space
            </summary>
        </member>
        <member name="P:Glaives.Core.Actor.LocalRotation">
            <summary>
            The rotation in local space
            </summary>
        </member>
        <member name="P:Glaives.Core.Actor.LocalScale">
            <summary>
            
            </summary>
        </member>
        <member name="P:Glaives.Core.Actor.Position">
            <summary>
            The position in world space
            </summary>
        </member>
        <member name="P:Glaives.Core.Actor.Rotation">
            <summary>
            The rotation in world space
            </summary>
        </member>
        <member name="P:Glaives.Core.Actor.Scale">
            <summary>
            The scale in world space
            </summary>
        </member>
        <member name="P:Glaives.Core.Actor.Up">
            <summary>
            The up vector
            </summary>
        </member>
        <member name="P:Glaives.Core.Actor.Right">
            <summary>
            The right vector
            </summary>
        </member>
        <member name="P:Glaives.Core.Actor.LocalMatrix">
            <summary>
            The local space matrix
            </summary>
        </member>
        <member name="P:Glaives.Core.Actor.WorldMatrix">
            <summary>
            The world space matrix
            </summary>
        </member>
        <member name="P:Glaives.Core.Actor.InverseWorldMatrix">
            <summary>
            The inverse world space matrix
            </summary>
        </member>
        <member name="P:Glaives.Core.Actor.InputEnabled">
            <summary>
            Whether or not the actor should receive input events
            </summary>
        </member>
        <member name="P:Glaives.Core.Actor.Engine">
            <summary>
            A shorthand to the engine singleton
            </summary>
        </member>
        <member name="P:Glaives.Core.Actor.CoroutineRunner">
            <summary>
            The coroutine runner for this actor
            </summary>
        </member>
        <member name="P:Glaives.Core.Actor.InputBinder">
            <summary>
            <para>Contains functionality for binding input to function handlers</para>
            <para>Each actor has it's own input binder</para>
            </summary>
        </member>
        <member name="F:Glaives.Core.Actor.Immutable">
            <summary>
            Whether or not the actor can be re-parented or destroyed (internal use only)
            </summary>
        </member>
        <member name="M:Glaives.Core.Actor.#ctor">
            <inheritdoc />
        </member>
        <member name="M:Glaives.Core.Actor.DoRecursive(System.Action{Glaives.Core.Actor},System.Boolean)">
            <summary>
            Performs an action recursively for actors under this actor in the hierarchy (and self if includeSelf = true)
            </summary>
            <param name="action"></param>
            <param name="includeSelf">Wheter or not we should perform this action on ourself as well</param>
            <returns>The amount of actors the action was operated on</returns>
        </member>
        <member name="M:Glaives.Core.Actor.Unparent">
            <summary>
            Parent the actor to the level root
            </summary>
        </member>
        <member name="M:Glaives.Core.Actor.Destroy">
            <summary>
            <para>Marks this actor for destroy and it's children recursively</para>
            <para>Marked actors will be destroyed at the end of the frame</para>
            </summary>
        </member>
        <member name="M:Glaives.Core.Actor.ForceDestroy">
            <summary>
            Destroy even when immutable (used to unload levels)
            </summary>
        </member>
        <member name="M:Glaives.Core.Actor.SetParentInternal(Glaives.Core.Actor)">
            <summary>
            This is only part of the Parent.Set code, Do not call this function from outside the Parent.Set
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Glaives.Core.Actor.Initialize">
            <summary>
            Called after the load level coroutine is completed or immediately if the actor is created after level loading 
            </summary>
        </member>
        <member name="M:Glaives.Core.Actor.Tick(System.Single)">
            <summary>
            Called every tick
            </summary>
            <param name="deltaTime">The elapsed time in seconds since the last tick</param>
        </member>
        <member name="M:Glaives.Core.Actor.ReceiveInputAction(Glaives.Core.Input.KeyState,Glaives.Core.Input.Key,System.Int32)">
            <summary>
            Process an input event if input is enabled for this actor
            </summary>
            <param name="keyState"></param>
            <param name="key">The key that triggered this event</param>
            <param name="gamepadId">The id of the gamepad that triggered this event (if it is triggered by a gamepad)</param>
        </member>
        <member name="M:Glaives.Core.Actor.ReceiveInputAxis(Glaives.Core.Input.InputAxis,System.Single,System.Int32)">
            <summary>
            Process an input axis event if input is enabled for this actor
            </summary>
            <param name="axis">The axis</param>
            <param name="value">The value of the axis (can be between 0 and 1 or -1 and 1 depending on the type of axis)</param>
            <param name="gamepadId">The id of the gamepad that triggered this event (if it is triggered by a gamepad)</param>
        </member>
        <member name="T:Glaives.Core.Configuration.GeneralSettings">
            <summary>
            General engine settings
            </summary>
        </member>
        <member name="T:Glaives.Core.Configuration.InputSettings">
            <summary>
            Engine settings related to input
            </summary>
        </member>
        <member name="P:Glaives.Core.Configuration.InputSettings.ActionBindings">
            <summary>
            The input action bindings
            </summary>
        </member>
        <member name="P:Glaives.Core.Configuration.InputSettings.AxisBindings">
            <summary>
            The input axis bindings
            </summary>
        </member>
        <member name="M:Glaives.Core.Configuration.InputSettings.GetDeadzoneForAxis(Glaives.Core.Input.InputAxis)">
            <summary>
            The deadzone for a specified axis
            </summary>
            <param name="axis"></param>
            <returns></returns>
        </member>
        <member name="T:Glaives.Core.Configuration.Settings">
            <summary>
            Root class for all engine settings
            </summary>
        </member>
        <member name="M:Glaives.Core.Configuration.Settings.Save(System.String)">
            <summary>
            Serialize the settings to an XML file
            </summary>
            <param name="settingsPath"></param>
        </member>
        <member name="M:Glaives.Core.Configuration.Settings.FromFile(System.String)">
            <summary>
            Load the settings from an XML file
            </summary>
            <param name="settingsFile">The XML file which contains the settings</param>
        </member>
        <member name="T:Glaives.Core.Configuration.VideoSettings">
            <summary>
            Engine settings related to windowing and graphics
            </summary>
        </member>
        <member name="P:Glaives.Core.Configuration.VideoSettings.Width">
            <summary>
            The width of the window
            </summary>
        </member>
        <member name="P:Glaives.Core.Configuration.VideoSettings.Height">
            <summary>
            The height of the window
            </summary>
        </member>
        <member name="P:Glaives.Core.Configuration.VideoSettings.Title">
            <summary>
            The title of the window
            </summary>
        </member>
        <member name="P:Glaives.Core.Configuration.VideoSettings.VSync">
            <summary>
            Whether or not the window should use vertical synchronization
            </summary>
        </member>
        <member name="P:Glaives.Core.Configuration.VideoSettings.TargetFps">
            <summary>
            <para>The desired frames per second</para>
            <para>This is an approximation, actual fps may vary</para>
            <para>0 means unlimited</para>
            </summary>
        </member>
        <member name="T:Glaives.Core.ContentCreateOptions">
            <summary>
            Base class for any content create options
            </summary>
        </member>
        <member name="M:Glaives.Core.ContentCreateOptions.IsEqualContent(Glaives.Core.ContentCreateOptions)">
            <summary>
            Whether or not the content create options are identical
            This check avoids duplicate content loading
            </summary>
            <param name="otherContent">The other content create options</param>
        </member>
        <member name="T:Glaives.Core.ContentLoader">
            <summary>
            <para>Loads and caches content files</para>
            <para>When loading content, the content loader will first check if this file was loaded previously (with the same create options)</para>
            <para>If it is present in the content cache it will return the cached content, otherwise it will load it and add it to the content cache</para>
            </summary>
        </member>
        <member name="M:Glaives.Core.ContentLoader.LoadFont(System.String,Glaives.Core.Graphics.FontCreateOptions)">
            <summary>
            Load a font file (supported formats: TTF and OTF)
            </summary>
            <param name="file">The font file</param>
            <param name="createOptions">The create options used to load the font</param>
            <returns></returns>
        </member>
        <member name="M:Glaives.Core.ContentLoader.LoadTexture(System.String,Glaives.Core.Graphics.TextureCreateOptions)">
            <summary>
            Load a texture (supported formats: Png, Jpeg, Bmp and Gif)
            </summary>
            <param name="file">The texture file to load</param>
            <param name="createOptions">The create options used to load the texture</param>
            <returns></returns>
        </member>
        <member name="M:Glaives.Core.ContentLoader.LoadShader(System.String,System.String)">
            <summary>
            Return loaded or cached shader
            </summary>
            <param name="vertexShaderFile">The vertex shader file to load</param>
            <param name="fragmentShaderFile">The fragment shader file to load</param>
            <returns>The shader</returns>
        </member>
        <member name="M:Glaives.Core.ContentLoader.DisposeAllContent">
            <summary>
            Disposes all cached content
            </summary>
        </member>
        <member name="T:Glaives.Core.Coroutines.Coroutine">
            <summary>
            <para>A coroutine contains the routine and it's callbacks</para>
            <para>Also provides static utility methods for yield operations</para>
            </summary>
        </member>
        <member name="F:Glaives.Core.Coroutines.Coroutine.Routine">
            <summary>
            The running routine
            </summary>
        </member>
        <member name="F:Glaives.Core.Coroutines.Coroutine.CompletedCallback">
            <summary>
            The callback that gets invoked when the routine terminates or is stopped
            </summary>
        </member>
        <member name="M:Glaives.Core.Coroutines.Coroutine.WaitForSeconds(System.Single)">
            <summary>
            Yield return this method in a coroutine to make it wait for a specified amount of seconds
            before continuing past the yield 
            </summary>
            <param name="seconds">The amount of seconds to wait</param>
        </member>
        <member name="M:Glaives.Core.Coroutines.Coroutine.WaitForTicks(System.UInt32)">
            <summary>
            Yield return this method in a coroutine to make it wait for a specified amount of ticks
            before continuing past the yield
            </summary>
            <param name="ticks">The amount of ticks to wait</param>
        </member>
        <member name="T:Glaives.Core.Coroutines.CoroutineCallbacks">
            <summary>
            A collection of delegate declarations associated with coroutines
            </summary>
        </member>
        <member name="T:Glaives.Core.Coroutines.CoroutineCallbacks.CoroutineCompletedCallback">
            <summary>
            The delegate declaration of the coroutine completed callback
            </summary>
        </member>
        <member name="T:Glaives.Core.Coroutines.CoroutineRunner">
            <summary>
            Runs and stops coroutines
            </summary>
        </member>
        <member name="P:Glaives.Core.Coroutines.CoroutineRunner.RunningCoroutines">
            <summary>
            The coroutines that are currently running on this coroutine runner
            </summary>
        </member>
        <member name="M:Glaives.Core.Coroutines.CoroutineRunner.RunCoroutine(System.Collections.IEnumerator,Glaives.Core.Coroutines.CoroutineCallbacks.CoroutineCompletedCallback)">
            <summary>
            Run a new coroutine
            </summary>
            <param name="routine">The routine to run</param>
            <param name="completedCallback">The callback will be called after the routine has either terminates or is stopped</param>
        </member>
        <member name="M:Glaives.Core.Coroutines.CoroutineRunner.StopCoroutine(System.Collections.IEnumerator)">
            <summary>
            Stop a running routine
            </summary>
            <param name="routine">The routine to stop (does nothing if the routine is not running)</param>
        </member>
        <member name="M:Glaives.Core.Coroutines.CoroutineRunner.StopAllCoroutines">
            <summary>
            Stop all coroutines associated with this coroutine runner
            </summary>
        </member>
        <member name="M:Glaives.Core.Diagnostics.Debugger.Info(System.Object)">
            <summary>
            <para>Log an information message (something non-problematic)</para>
            <para>Will not be included in the error log file</para>
            </summary>
            <param name="infoMessage"></param>
        </member>
        <member name="M:Glaives.Core.Diagnostics.Debugger.Warning(System.Object)">
            <summary>
            <para>Log a warning message (something potentially problematic)</para>
            <para>Will be included in the error log file</para>
            </summary>
            <param name="warningMessage"></param>
        </member>
        <member name="M:Glaives.Core.Diagnostics.Debugger.Error(System.Object)">
            <summary>
            <para>Log an error message (something critically problematic)</para>
            <para>Will be included in the error log file</para>
            </summary>
            <param name="errorMessage"></param>
        </member>
        <member name="T:Glaives.Core.Diagnostics.LogType">
            <summary>
            The type of log message
            </summary>
        </member>
        <member name="F:Glaives.Core.Diagnostics.LogType.Info">
            <summary>
            An info log is non-problematic message
            </summary>
        </member>
        <member name="F:Glaives.Core.Diagnostics.LogType.Warning">
            <summary>
            A warning log is a message about something which is could cause issues
            </summary>
        </member>
        <member name="F:Glaives.Core.Diagnostics.LogType.Error">
            <summary>
            An error log is a message about something that is a critical, application breaking issue
            </summary>
        </member>
        <member name="P:Glaives.Core.Diagnostics.Statistics.Fps">
            <summary>
            The current frame rate 
            </summary>
        </member>
        <member name="T:Glaives.Core.Engine">
            <summary>
            The service provider for all engine features
            </summary>
        </member>
        <member name="P:Glaives.Core.Engine.Get">
            <summary>
            Get the engine singleton
            </summary>
        </member>
        <member name="P:Glaives.Core.Engine.Settings">
            <summary>
            Contains all project-specific engine settings
            </summary>
        </member>
        <member name="P:Glaives.Core.Engine.Stats">
            <summary>
            Engine statistics
            </summary>
        </member>
        <member name="P:Glaives.Core.Engine.GameInstance">
            <summary>
            The game instance
            </summary>
        </member>
        <member name="P:Glaives.Core.Engine.Debug">
            <summary>
            Debug utility
            </summary>
        </member>
        <member name="P:Glaives.Core.Engine.Content">
            <summary>
            <para>Loads and caches content files</para>
            <para>When loading content, the content loader will first check if this file was loaded previously</para>
            <para>If it is present in the content cache it will return the cached content, otherwise it will load it and add it to the content cache</para>
            </summary>
        </member>
        <member name="P:Glaives.Core.Engine.Graphics">
            <summary>
            Contains rendering-related functionality
            </summary>
        </member>
        <member name="P:Glaives.Core.Engine.Viewport">
            <summary>
            The viewport of the window
            </summary>
        </member>
        <member name="P:Glaives.Core.Engine.WindowHandle">
            <summary>
            The handle to the native window
            </summary>
        </member>
        <member name="P:Glaives.Core.Engine.CurrentLevel">
            <summary>
            The currently loaded level
            </summary>
        </member>
        <member name="M:Glaives.Core.Engine.Initialize``2">
            <summary>
            Initializes all modules and loads the initial level
            </summary>
            <typeparam name="TGameInstanceType">The type of your custom game instance (create a class and inherit from GameInstance)</typeparam>
            <typeparam name="TInitialLevelType">The type of your custom level to load as the first level (create a class and inherit from Level)</typeparam>
        </member>
        <member name="M:Glaives.Core.Engine.Initialize(System.Type,System.Type)">
            <summary>
            Initializes all modules and loads the initial level
            </summary>
            <param name="gameInstanceType">The type of your custom game instance (create a class and inherit from GameInstance)</param>
            <param name="initialLevelType">The type of your custom level to load as the first level (create a class and inherit from Level)</param>
        </member>
        <member name="M:Glaives.Core.Engine.LoadLevel``1">
            <summary>
            Load a new level and unload the current one
            </summary>
            <typeparam name="TLevel">The level type</typeparam>
        </member>
        <member name="M:Glaives.Core.Engine.LoadLevel(System.Type)">
            <summary>
            Load a new level and unload the current one
            </summary>
            <param name="levelType">The level type (must derive from Level)</param>
        </member>
        <member name="M:Glaives.Core.Engine.Quit">
            <summary>
            Quit the game and close the window
            </summary>
        </member>
        <member name="M:Glaives.Core.Engine.OnActorConstruction(Glaives.Core.Actor)">
            <summary>
            Called in the actor constructor
            </summary>
            <param name="newActor"></param>
        </member>
        <member name="T:Glaives.Core.GameInstance">
            <summary>
            A game instance is a persistent class that will exist until the program closes
            </summary>
        </member>
        <member name="P:Glaives.Core.GameInstance.Engine">
            <summary>
            A shorthand to the engine singleton
            </summary>
        </member>
        <member name="M:Glaives.Core.GameInstance.InitializeSettings">
            <summary>
            <para>The engine will obtain it's settings from this call when it initializes</para>
            <para>Called once before Initialize</para>
            </summary>  
            <returns>The settings you want to use for the application</returns>
        </member>
        <member name="M:Glaives.Core.GameInstance.Initialize">
            <summary>
            Called after the engine modules have been initialized
            </summary>
        </member>
        <member name="M:Glaives.Core.GameInstance.ReceiveLogs(Glaives.Core.Diagnostics.LogType,System.String,System.String,System.String,System.Int32)">
            <summary>
            Receive engine log messages
            </summary>
            <param name="logType">The type of log message</param>
            <param name="message">The log message</param>
            <param name="className">The class which invoked this log</param>
            <param name="methodName">The method in the class which invoked this log</param>
            <param name="lineNumber">The number of the line in the method that invoked this log</param>
        </member>
        <member name="F:Glaives.Core.Graphics.BlendMode.Factor.Zero">
            <summary>(0, 0, 0, 0)</summary>
        </member>
        <member name="F:Glaives.Core.Graphics.BlendMode.Factor.One">
            <summary>(1, 1, 1, 1)</summary>
        </member>
        <member name="F:Glaives.Core.Graphics.BlendMode.Factor.SrcColor">
            <summary>(src.r, src.g, src.b, src.a)</summary>
        </member>
        <member name="F:Glaives.Core.Graphics.BlendMode.Factor.OneMinusSrcColor">
            <summary>(1, 1, 1, 1) - (src.r, src.g, src.b, src.a)</summary>
        </member>
        <member name="F:Glaives.Core.Graphics.BlendMode.Factor.DstColor">
            <summary>(dst.r, dst.g, dst.b, dst.a)</summary>
        </member>
        <member name="F:Glaives.Core.Graphics.BlendMode.Factor.OneMinusDstColor">
            <summary>(1, 1, 1, 1) - (dst.r, dst.g, dst.b, dst.a)</summary>
        </member>
        <member name="F:Glaives.Core.Graphics.BlendMode.Factor.SrcAlpha">
            <summary>(src.a, src.a, src.a, src.a)</summary>
        </member>
        <member name="F:Glaives.Core.Graphics.BlendMode.Factor.OneMinusSrcAlpha">
            <summary>(1, 1, 1, 1) - (src.a, src.a, src.a, src.a)</summary>
        </member>
        <member name="F:Glaives.Core.Graphics.BlendMode.Factor.DstAlpha">
            <summary>(dst.a, dst.a, dst.a, dst.a)</summary>
        </member>
        <member name="F:Glaives.Core.Graphics.BlendMode.Factor.OneMinusDstAlpha">
            <summary>(1, 1, 1, 1) - (dst.a, dst.a, dst.a, dst.a)</summary>
        </member>
        <member name="T:Glaives.Core.Graphics.BlendMode.Equation">
            <summary>
            Enumeration of the blending equations
            </summary>
        </member>
        <member name="F:Glaives.Core.Graphics.BlendMode.Equation.Add">
            <summary>Pixel = Src * SrcFactor + Dst * DstFactor</summary>
        </member>
        <member name="F:Glaives.Core.Graphics.BlendMode.Equation.Subtract">
            <summary>Pixel = Src * SrcFactor - Dst * DstFactor</summary>
        </member>
        <member name="F:Glaives.Core.Graphics.BlendMode.Alpha">
            <summary>Blend source and dest according to dest alpha</summary>
        </member>
        <member name="F:Glaives.Core.Graphics.BlendMode.Add">
            <summary>Add source to dest</summary>
        </member>
        <member name="F:Glaives.Core.Graphics.BlendMode.Multiply">
            <summary>Multiply source and dest</summary>
        </member>
        <member name="F:Glaives.Core.Graphics.BlendMode.None">
            <summary>Overwrite dest with source</summary>
        </member>
        <member name="F:Glaives.Core.Graphics.BlendMode.ColorSrcFactor">
            <summary>Source blending factor for the color channels</summary>
        </member>
        <member name="F:Glaives.Core.Graphics.BlendMode.ColorDstFactor">
            <summary>Destination blending factor for the color channels</summary>
        </member>
        <member name="F:Glaives.Core.Graphics.BlendMode.ColorEquation">
            <summary>Blending equation for the color channels</summary>
        </member>
        <member name="F:Glaives.Core.Graphics.BlendMode.AlphaSrcFactor">
            <summary>Source blending factor for the alpha channel</summary>
        </member>
        <member name="F:Glaives.Core.Graphics.BlendMode.AlphaDstFactor">
            <summary>Destination blending factor for the alpha channel</summary>
        </member>
        <member name="F:Glaives.Core.Graphics.BlendMode.AlphaEquation">
            <summary>Blending equation for the alpha channel</summary>
        </member>
        <member name="M:Glaives.Core.Graphics.BlendMode.#ctor(Glaives.Core.Graphics.BlendMode.Factor,Glaives.Core.Graphics.BlendMode.Factor)">
            <summary>
            Construct the blend mode given the factors and equation
            </summary>
            <param name="sourceFactor">Specifies how to compute the source factor for the color and alpha channels.</param>
            <param name="destinationFactor">Specifies how to compute the destination factor for the color and alpha channels.</param>
        </member>
        <member name="M:Glaives.Core.Graphics.BlendMode.#ctor(Glaives.Core.Graphics.BlendMode.Factor,Glaives.Core.Graphics.BlendMode.Factor,Glaives.Core.Graphics.BlendMode.Equation)">
            <summary>
            Construct the blend mode given the factors and equation
            </summary>
            <param name="sourceFactor">Specifies how to compute the source factor for the color and alpha channels.</param>
            <param name="destinationFactor">Specifies how to compute the destination factor for the color and alpha channels.</param>
            <param name="blendEquation">Specifies how to combine the source and destination colors and alpha.</param>
        </member>
        <member name="M:Glaives.Core.Graphics.BlendMode.#ctor(Glaives.Core.Graphics.BlendMode.Factor,Glaives.Core.Graphics.BlendMode.Factor,Glaives.Core.Graphics.BlendMode.Equation,Glaives.Core.Graphics.BlendMode.Factor,Glaives.Core.Graphics.BlendMode.Factor,Glaives.Core.Graphics.BlendMode.Equation)">
            <summary>
            Construct the blend mode given the factors and equation
            </summary>
            <param name="colorSourceFactor">Specifies how to compute the source factor for the color channels.</param>
            <param name="colorDestinationFactor">Specifies how to compute the destination factor for the color channels.</param>
            <param name="colorBlendEquation">Specifies how to combine the source and destination colors.</param>
            <param name="alphaSourceFactor">Specifies how to compute the source factor.</param>
            <param name="alphaDestinationFactor">Specifies how to compute the destination factor.</param>
            <param name="alphaBlendEquation">Specifies how to combine the source and destination alphas.</param>
        </member>
        <member name="M:Glaives.Core.Graphics.BlendMode.op_Equality(Glaives.Core.Graphics.BlendMode,Glaives.Core.Graphics.BlendMode)">
            <summary>
            Compare two blend modes and checks if they are equal
            </summary>
            <returns>Blend Modes are equal</returns>
        </member>
        <member name="M:Glaives.Core.Graphics.BlendMode.op_Inequality(Glaives.Core.Graphics.BlendMode,Glaives.Core.Graphics.BlendMode)">
            <summary>
            Compare two blend modes and checks if they are not equal
            </summary>
            <returns>Blend Modes are not equal</returns>
        </member>
        <member name="M:Glaives.Core.Graphics.BlendMode.Equals(System.Object)">
            <summary>
            Compare blend mode and object and checks if they are equal
            </summary>
            <param name="obj">Object to check</param>
            <returns>Object and blend mode are equal</returns>
        </member>
        <member name="M:Glaives.Core.Graphics.BlendMode.Equals(Glaives.Core.Graphics.BlendMode)">
            <summary>
            Compare two blend modes and checks if they are equal
            </summary>
            <param name="other">Blend Mode to check</param>
            <returns>blend modes are equal</returns>
        </member>
        <member name="M:Glaives.Core.Graphics.BlendMode.GetHashCode">
            <summary>
            Provide a integer describing the object
            </summary>
            <returns>Integer description of the object</returns>
        </member>
        <member name="P:Glaives.Core.Graphics.Color.White">
            <summary>
            (R=1, G=1, B=1, A=1);
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.Color.Black">
            <summary>
            (R=0, G=0, B=0, A=1);
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.Color.Red">
            <summary>
            (R=1, G=0, B=0, A=1);
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.Color.Green">
            <summary>
            (R=0, G=1, B=0, A=1);
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.Color.Blue">
            <summary>
            (R=0, G=0, B=1, A=1);
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.Color.Magenta">
            <summary>
            (R=1, G=0, B=1, A=1);
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.Color.Transparent">
            <summary>
            (R=0, G=0, B=0, A=0);
            </summary>
        </member>
        <member name="M:Glaives.Core.Graphics.Color.ToRgbaBytes">
            <summary>
            Create a byte array of rgba values (between 0 and 255)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Glaives.Core.Graphics.Color.RgbaToBgra(System.Byte[])">
            <summary>
            Convert a RGBA byte array to a BGRA byte array
            </summary>
            <param name="rgbaBytes">The bytes in RGBA order</param>
        </member>
        <member name="M:Glaives.Core.Graphics.Color.BgraToRgba(System.Byte[])">
            <summary>
            Convert a BGRA byte array to a RGBA byte array
            </summary>
            <param name="bgraBytes">The bytes in BGRA order</param>
        </member>
        <member name="M:Glaives.Core.Graphics.Color.RgbaToRgb(System.Byte[])">
            <summary>
            Convert a RGBA byte array to a RGB byte array
            </summary>
            <param name="rgbaBytes">The RGBA bytes</param>
        </member>
        <member name="M:Glaives.Core.Graphics.Color.RgbToRgba(System.Byte[],System.Byte)">
            <summary>
            Convert a RGB byte array to a RGBA byte array
            </summary>
            <param name="rgbBytes">The RGB bytes</param>
            <param name="alpha">The value to use for the alpha channel</param>
        </member>
        <member name="M:Glaives.Core.Graphics.ColorExtensions.ToBytes(System.Collections.Generic.IEnumerable{Glaives.Core.Graphics.Color})">
            <summary>
            <para>Create an RGBA byte array of rgba values (between 0 and 255)</para>
            <para>The RGBA byte array will be 4 times the length of the color collection</para>
            </summary>
            <param name="colors">The colors to convert to RGBA bytes</param>
            <returns>The RGBA bytes</returns>
        </member>
        <member name="M:Glaives.Core.Graphics.ColorExtensions.ToColors(System.Collections.Generic.IEnumerable{System.Byte})">
            <summary>
            <para>Convert the RGBA bytes to colors</para>
            <para>The color array will be a quarter the length of the byte array</para>
            </summary>
            <param name="bytes">The RGBA bytes to convert</param>
            <returns>The colors</returns>
        </member>
        <member name="T:Glaives.Core.Graphics.DrawableActor">
            <inheritdoc />
            <summary>
            <para>An actor that contains geometry that can be drawn</para>
            <para>You can create your own drawable actor by inheriting from drawable actor and implementing the necessary methods</para>
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.DrawableActor.Opacity">
            <summary>
            How transparent this actor is (between 0 and 1)
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.DrawableActor.Color">
            <summary>
            The RGBA color of this actor
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.DrawableActor.LocalBounds">
            <summary>
            <para>The bounds of this drawable actor in local space</para>
            <para>Ignores the transformations (translation, rotation ,scale) that are applied</para>
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.DrawableActor.Origin">
            <summary>
            The normalized origin of the actor (between (0, 0) and (1, 1))
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.DrawableActor.BlendMode">
            <summary>
            The blending modes to use for this drawable actor
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.DrawableActor.Shader">
            <summary>
            The shader to use for this drawable actor
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.DrawableActor.Texture">
            <summary>
            The texture of this drawable actor
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.DrawableActor.DrawLayer">
            <summary>
            The draw layers manage the order at which the drawable actors are drawn (higher layers will overlap lower layers)
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.DrawableActor.Bounds">
            <summary>
            <para>The global bounds of this drawable actor</para>
            <para>Takes into account the transformations (translation, rotation, scale) that are applied</para>
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.DrawableActor.LocalBoundsInternal">
            <summary>
            Internal use for the Actor base class only
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.DrawableActor.OriginInternal">
            <summary>
            Internal use for the Actor base class only
            </summary>
        </member>
        <member name="M:Glaives.Core.Graphics.DrawableActor.Transformed">
            <inheritdoc />
        </member>
        <member name="M:Glaives.Core.Graphics.DrawableActor.ReconstructVertices">
            <summary>
            <para>Marks the vertices as dirty, FillVertexArray will be called again by the GraphicsDevice in the render stage</para>
            <para>Construction will always happen initially when the drawable actor is created</para>
            <para>Call when a change was made that affects the vertices</para>
            <para>Transformational changes (Position, Rotation, Scale), Color and Flips will automatically cause the vertices to be re-constructed</para>
            </summary>
        </member>
        <member name="M:Glaives.Core.Graphics.DrawableActor.FillVertexArray(Glaives.Core.Graphics.Vertex[]@)">
            <summary>
            <para>Do not CALL this function ever, it is merely meant to implement</para>
            <para>Defines the geometry of the drawable actor</para>
            <para>Fill the vertex array (vertices) in this function</para>
            <para>Tip: don't re-create or resize the vertex array when it is not needed (to minimize CPU usage and GC collections)</para>
            </summary>
            <returns></returns>
        </member>
        <member name="T:Glaives.Core.Graphics.DynamicTexture">
            <inheritdoc />
            <summary>
            <para>Unlike a normal texture, a dynamic texture has direct access to it's pixel data</para>
            <para>Use a dynamic texture if you need flexible access to read and write pixel data</para>
            <para>A dynamic texture can be convert to a normal texture and vise-versa (do not forget to dispose the dynamic texture when you are done with it)</para>
            <para>Supported formats: Png, Jpeg, Bmp and Gif</para>
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.DynamicTexture.Size">
            <summary>
            The dimensions of the dynamic texture
            </summary>
        </member>
        <member name="M:Glaives.Core.Graphics.DynamicTexture.#ctor(System.String)">
            <summary>
            Load a dynamic texture (supported formats: Png, Jpeg, Bmp and Gif)
            </summary>
            <param name="file">The path to the file (with extension)</param>
        </member>
        <member name="M:Glaives.Core.Graphics.DynamicTexture.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a new dynamic texture
            </summary>
            <param name="width">The width of the dynamic texture</param>
            <param name="height">The height of the dynamic texture</param>
        </member>
        <member name="M:Glaives.Core.Graphics.DynamicTexture.#ctor(Glaives.Core.Graphics.Texture)">
            <summary>
            Create a new dynamic texture 
            </summary>
            <param name="texture">A texture to copy the pixel data from</param>
        </member>
        <member name="M:Glaives.Core.Graphics.DynamicTexture.ReadColors">
            <summary>
            <para>Read the RGBA bytes from the dynamic texture and convert them to colors</para>
            <para>The length of the color array is (Size.X * Size.Y)</para>
            </summary>
            <returns>The pixels as colors</returns>
        </member>
        <member name="M:Glaives.Core.Graphics.DynamicTexture.ReadBytes">
            <summary>
            <para>Read all the RGBA bytes from the dynamic texture</para>
            <para>The length of the byte array is (Size.X * Size.Y * 4)</para>
            </summary>
            <returns>The pixels as RGBA bytes</returns>
        </member>
        <member name="M:Glaives.Core.Graphics.DynamicTexture.ReadColors(Glaives.Core.IntRect)">
            <summary>
            <para>Read the RGBA bytes from the dynamic texture and convert them to colors</para>
            <para>The length of the color array will be (region.Width * region.Height) unless a part of the region falls of the texture, 
            the region will then size down to fit the texture exactly</para>
            </summary>
            <param name="region">The region on the dynamic texture to read from</param>
            <returns>The pixels as colors</returns>
        </member>
        <member name="M:Glaives.Core.Graphics.DynamicTexture.ReadBytes(Glaives.Core.IntRect)">
            <summary>
            <para>Read the RGBA bytes from the dynamic texture</para>
            <para>The length of the byte array will be (region.Width * region.Height * 4) unless a part of the region falls of the texture, 
            the region will then size down to fit the texture exactly</para>
            </summary>
            <param name="region">The region on the dynamic texture to read from</param>
            <returns>The pixels as RGBA bytes</returns>
        </member>
        <member name="M:Glaives.Core.Graphics.DynamicTexture.WriteBytes(System.Byte[])">
            <summary>
            <para>Write RGBA bytes to the dynamic texture</para>
            </summary>
            <param name="bytes">The RGBA bytes to write</param>
        </member>
        <member name="M:Glaives.Core.Graphics.DynamicTexture.WriteColors(Glaives.Core.Graphics.Color[])">
            <summary>
            <para>Write the colors to the dynamic texture</para>
            </summary>
            <param name="colors">The colors to write</param>
        </member>
        <member name="M:Glaives.Core.Graphics.DynamicTexture.WriteColors(Glaives.Core.Graphics.Color[],Glaives.Core.IntRect)">
            <summary>
            <para>Write the colors to the dynamic texture in the specified region</para>
            </summary>
            <param name="colors">The colors to write</param>
            <param name="region">The region on the dynamic texture to write into</param>
        </member>
        <member name="M:Glaives.Core.Graphics.DynamicTexture.WriteColor(Glaives.Core.Graphics.Color,Glaives.Core.IntRect)">
            <summary>
            <para>Write a single color into all pixels in the region</para>
            </summary>
            <param name="color">The color to write</param>
            <param name="region">The region on the dynamic texture to write into</param>
        </member>
        <member name="M:Glaives.Core.Graphics.DynamicTexture.WriteColor(Glaives.Core.Graphics.Color)">
            <summary>
            <para>Write a single color into all pixels in the dynamic texture</para>
            </summary>
            <param name="color">The color to write</param>
        </member>
        <member name="M:Glaives.Core.Graphics.DynamicTexture.WriteDynamicTexture(Glaives.Core.Graphics.DynamicTexture,System.Int32,System.Int32)">
            <summary>
            <para>Write a dynamic texture into this dynamic texture</para>
            <para>The input dynamic texture must not be larger than the target dynamic texture</para>
            </summary>
            <param name="dynamicTexture">The dynamic texture to write into the target dynamic texture</param>
            <param name="x">The x start location on the target dynamic texture</param>
            <param name="y">The y start location on the target dynamic texture</param>
        </member>
        <member name="M:Glaives.Core.Graphics.DynamicTexture.WriteBytes(System.Byte[],Glaives.Core.IntRect)">
            <summary>
            <para>Write the RGBA bytes to the dynamic texture</para>
            </summary>
            <param name="bytes">The RGBA bytes to write</param>
            <param name="region">The region on the dynamic texture to write to</param>
        </member>
        <member name="M:Glaives.Core.Graphics.DynamicTexture.Save(System.String)">
            <summary>
            Save the dynamic texture to a file
            </summary>
            <param name="file">The path and file name + extension</param>
        </member>
        <member name="M:Glaives.Core.Graphics.DynamicTexture.Dispose">
            <inheritdoc />
            <summary>
            Dispose the dynamic texture
            </summary>
        </member>
        <member name="T:Glaives.Core.Graphics.Font">
            <inheritdoc cref="T:Glaives.Core.LoadableContent" />
            <summary>
            A font is used to draw text, it supports TTF (TrueTypeFont) and OTF (OpenTypeFont) files
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.Font.MaxFontSize">
            <summary>
            The maximum size allowed for fonts
            </summary>
        </member>
        <member name="F:Glaives.Core.Graphics.Font.FontSize">
            <summary>
            The size of the font
            </summary>
        </member>
        <member name="M:Glaives.Core.Graphics.Font.Dispose">
            <inheritdoc />
        </member>
        <member name="P:Glaives.Core.Graphics.Font.Default">
            <summary>
            Consolas regular 32
            </summary>
        </member>
        <member name="T:Glaives.Core.Graphics.FontCreateOptions">
            <inheritdoc />
            <summary>
            The create options to use for the font
            </summary>
        </member>
        <member name="F:Glaives.Core.Graphics.FontCreateOptions.FontSize">
            <summary>
            The size of the font
            </summary>
        </member>
        <member name="M:Glaives.Core.Graphics.FontCreateOptions.#ctor(System.Int32)">
            <summary>
            Create options for fonts
            </summary>
            <param name="fontSize">The size of the font</param>
        </member>
        <member name="M:Glaives.Core.Graphics.FontCreateOptions.IsEqualContent(Glaives.Core.ContentCreateOptions)">
            <inheritdoc />
        </member>
        <member name="M:Glaives.Core.Graphics.FontCreateOptions.ToString">
            <inheritdoc />
        </member>
        <member name="P:Glaives.Core.Graphics.GraphicsDevice.DrawCalls">
            <summary>
            <para>The amount of draw calls to the GPU needed to render the level</para>
            <para>Actors with the same Shader, Texture, BlendMode and DrawLayer will be batched together into the same draw call</para>
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.GraphicsDevice.ScreenShader">
            <summary>
            <para>The screen shader is used to apply full-screen effects</para>
            <para>It is applied after all drawing is done</para>
            </summary>
        </member>
        <member name="T:Glaives.Core.Graphics.Shader">
            <summary>
            <para>A shader is a set of GLSL scripts that run on the GPU</para>
            <para>Glaives uses special variable names to identify different "in" and "out" variables</para>
            <para>To create your own shaders, follow the instruction at: http://www.TODOPLACELINKHERE.net/Shaders </para>
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.Shader.Default">
            <summary>
            A simple textured vertex and fragment shader
            </summary>
        </member>
        <member name="M:Glaives.Core.Graphics.Shader.FromString(System.String,System.String)">
            <summary>
            Construct a new shader from memory directly
            </summary>
            <param name="vertexShaderString"></param>
            <param name="fragmentShaderString"></param>
            <returns></returns>
        </member>
        <member name="M:Glaives.Core.Graphics.Shader.#ctor(System.String,System.String)">
            <summary>
            <para>Create a new shader instance from files</para>
            <para>Actors with different shader instances will be drawn in different draw calls</para>
            <para>To reduce draw calls, use the same shader instance for multiple actors</para>
            </summary>
            <param name="vertexShaderFile"></param>
            <param name="fragmentShaderFile"></param>
        </member>
        <member name="M:Glaives.Core.Graphics.Shader.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Glaives.Core.Graphics.Shapes.MakeQuad">
            <summary>
            Create a vertex array that represents a quad
            </summary>
            <returns></returns>
        </member>
        <member name="T:Glaives.Core.Graphics.Sprite">
            <inheritdoc />
            The sprite drawable actor
        </member>
        <member name="P:Glaives.Core.Graphics.Sprite.SourceRect">
            <summary>
            The region on the texture to use to draw the sprite
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.Sprite.FlipX">
            <summary>
            Whether or not to flip the sprite horizontally
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.Sprite.FlipY">
            <summary>
            Whether or not to flip the sprite vertically
            </summary>
        </member>
        <member name="M:Glaives.Core.Graphics.Sprite.#ctor(Glaives.Core.Graphics.Texture)">
            <inheritdoc />
        </member>
        <member name="M:Glaives.Core.Graphics.Sprite.#ctor(Glaives.Core.Graphics.Texture,Glaives.Core.IntRect)">
            <inheritdoc />
        </member>
        <member name="P:Glaives.Core.Graphics.Sprite.LocalBounds">
            <inheritdoc />
        </member>
        <member name="M:Glaives.Core.Graphics.Sprite.FillVertexArray(Glaives.Core.Graphics.Vertex[]@)">
            <inheritdoc />
        </member>
        <member name="T:Glaives.Core.Graphics.Text">
            <inheritdoc />
            The text drawable actor generates quads that represents characters from a font
        </member>
        <member name="P:Glaives.Core.Graphics.Text.String">
            <summary>
            The string to be drawn by the text actor
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.Text.StyleFlags">
            <summary>
            The styling applied to the text (flags)
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.Text.Alignment">
            <summary>
            The <see cref="T:Glaives.Core.Graphics.TextAlignment"/> anchors the lines to the left, center or right side of the text bounds
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.Text.Font">
            <summary>
            The <see cref="P:Glaives.Core.Graphics.Text.Font"/> used to draw the text
            </summary>
        </member>
        <member name="T:Glaives.Core.Graphics.TextAlignment">
            <summary>
            The text alignment anchors the lines to the left, center or right side of the text bounds
            </summary>
        </member>
        <member name="F:Glaives.Core.Graphics.TextAlignment.Left">
            <summary>
            Align text left
            </summary>
        </member>
        <member name="F:Glaives.Core.Graphics.TextAlignment.Center">
            <summary>
            Align text center
            </summary>
        </member>
        <member name="F:Glaives.Core.Graphics.TextAlignment.Right">
            <summary>
            Align text right
            </summary>
        </member>
        <member name="T:Glaives.Core.Graphics.TextStyleFlags">
            <summary>
            <para>The italic flag skews the vertices to appear to be italic (if you use an italic font, don not include the italic flag)</para>
            <para>The underline flag adds a underline to text lines as a generated quad</para>
            <para>The strikeout flag adds a line through the text as a generated quad</para>
            <para>At the moment, boldness can not be done artificially, if you want bold text you should load a bold font</para>
            </summary>
        </member>
        <member name="F:Glaives.Core.Graphics.TextStyleFlags.Regular">
            <summary>
            No modifications are done to the text
            </summary>
        </member>
        <member name="F:Glaives.Core.Graphics.TextStyleFlags.Italic">
            <summary>
            Skews the vertices to appear to be italic (if you use an italic font, don not include the italic flag)
            </summary>
        </member>
        <member name="F:Glaives.Core.Graphics.TextStyleFlags.Underline">
            <summary>
            Adds a underline to text lines as a generated quad
            </summary>
        </member>
        <member name="F:Glaives.Core.Graphics.TextStyleFlags.Strikeout">
            <summary>
            Adds a line through the text as a generated quad
            </summary>
        </member>
        <member name="T:Glaives.Core.Graphics.Texture">
            <inheritdoc cref="T:Glaives.Core.LoadableContent" />
            <summary>
            <para>A texture exists only on the GPU and is therefor not as flexible as a dynamic texture</para>
            <para>Use a dynamic texture if you want access and/or modify the pixel data on the CPU</para>
            <para>A dynamic texture can be converted to a texture and vise-versa (do not forget to dispose the dynamic texture when you are done with it)</para>
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.Texture.MaxTextureSize">
            <summary>
            The maximum width/height that a texture supports
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.Texture.Handle">
            <summary>
            The gl handle 
            </summary>
        </member>
        <member name="F:Glaives.Core.Graphics.Texture.Size">
            <summary>
            The dimensions of the texture
            </summary>
        </member>
        <member name="M:Glaives.Core.Graphics.Texture.#ctor(System.Int32,System.Int32,Glaives.Core.Graphics.Color,Glaives.Core.Graphics.TextureCreateOptions)">
            <summary>
            Create a new empty texture 
            </summary>
            <param name="width">The width of the texture</param>
            <param name="height">The height of the texture</param>
            <param name="color">The color for all pixels in the texture</param>
            <param name="createOptions">The create options</param>
        </member>
        <member name="M:Glaives.Core.Graphics.Texture.#ctor(System.Int32,System.Int32,System.Byte[],Glaives.Core.Graphics.TextureCreateOptions)">
            <summary>
            Create a new texture
            </summary>
            <param name="width">The width of the texture</param>
            <param name="height">The height of the texture</param>
            <param name="bytes">The RGBA bytes to load this texture with</param>
            <param name="createOptions">The create options</param>
        </member>
        <member name="M:Glaives.Core.Graphics.Texture.#ctor(Glaives.Core.Graphics.DynamicTexture,Glaives.Core.Graphics.TextureCreateOptions)">
            <summary>
            Create a new texture
            </summary>
            <param name="dynamicTexture">The dynamic texture to copy the pixel data from</param>
            <param name="createOptions">The create options</param>
        </member>
        <member name="M:Glaives.Core.Graphics.Texture.Update(System.Collections.Generic.IEnumerable{Glaives.Core.Graphics.Color},Glaives.Core.IntRect)">
            <summary>
            Update the texture on the GPU using 32-bit RGBA colors
            </summary>
            <param name="colors">The color pixels to be submitted to the texture</param>
            <param name="region">The region of the sub texture</param>
        </member>
        <member name="M:Glaives.Core.Graphics.Texture.Update(Glaives.Core.Graphics.Color)">
            <summary>
            Update all the pixels in the texture on the GPU to a single 32-bit RGBA color
            </summary>
            <param name="color">The color for all the pixels in the texture</param>
        </member>
        <member name="M:Glaives.Core.Graphics.Texture.Update(System.Byte[],Glaives.Core.IntRect)">
            <summary>
            Update the texture on the GPU
            </summary>
            <param name="bytes">The bytes to be submitted to the texture</param>
            <param name="region">The region of the sub texture</param>
        </member>
        <member name="M:Glaives.Core.Graphics.Texture.GetBytes">
            <summary>
            Get the RGBA bytes of the texture from the GPU
            </summary>
        </member>
        <member name="M:Glaives.Core.Graphics.Texture.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Glaives.Core.Graphics.TextureCreateOptions">
            <inheritdoc />
            <summary>
            The create options to use for the texture
            </summary>
        </member>
        <member name="F:Glaives.Core.Graphics.TextureCreateOptions.FilterMode">
            <summary>
            The way the texture is filtered
            </summary>
        </member>
        <member name="F:Glaives.Core.Graphics.TextureCreateOptions.WrapMode">
            <summary>
            The way the texture is wrapped outside of the texture coordinates
            </summary>
        </member>
        <member name="M:Glaives.Core.Graphics.TextureCreateOptions.#ctor(Glaives.Core.Graphics.TextureFilterMode,Glaives.Core.Graphics.TextureWrapMode)">
            <summary>
            Create new texture create options
            </summary>
            <param name="filterMode">The way the texture is filtered</param>
            <param name="wrapMode">The way the texture is wrapped outside of the texture coordinates</param>
        </member>
        <member name="M:Glaives.Core.Graphics.TextureCreateOptions.IsEqualContent(Glaives.Core.ContentCreateOptions)">
            <inheritdoc />
        </member>
        <member name="M:Glaives.Core.Graphics.TextureCreateOptions.ToString">
            <inheritdoc />
        </member>
        <member name="P:Glaives.Core.Graphics.TextureCreateOptions.Smooth">
            <summary>
            <para>FilterMode : Smooth</para>
            <para>WrapMode : ClampToEdge</para>
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.TextureCreateOptions.Sharp">
            <summary>
            <para>FilterMode : Sharp</para>
            <para>WrapMode : ClampToEdge</para>
            </summary>
        </member>
        <member name="T:Glaives.Core.Graphics.TextureFilterMode">
            <summary>
            The way the texture is filtered
            </summary>
        </member>
        <member name="F:Glaives.Core.Graphics.TextureFilterMode.Smooth">
            <summary>
            For smoother textures
            </summary>
        </member>
        <member name="F:Glaives.Core.Graphics.TextureFilterMode.Sharp">
            <summary>
            For pixel-perfect textures
            </summary>
        </member>
        <member name="T:Glaives.Core.Graphics.TextureWrapMode">
            <summary>
            The way the texture is sampled outside the coordinate range of 0 to 1
            </summary>
        </member>
        <member name="F:Glaives.Core.Graphics.TextureWrapMode.Repeat">
            <summary>
            The integer part of the coordinate is ignored and a repeated pattern is formed
            </summary>
        </member>
        <member name="F:Glaives.Core.Graphics.TextureWrapMode.MirroredRepeat">
            <summary>
            Same as Repeat but it will be mirrored when the integer part of the coordinate is odd
            </summary>
        </member>
        <member name="F:Glaives.Core.Graphics.TextureWrapMode.ClampToEdge">
            <summary>
            The coordinate will be clamped between 0 and 1
            </summary>
        </member>
        <member name="F:Glaives.Core.Graphics.TextureWrapMode.ClampToBorder">
            <summary>
            The coordinates that fall outside the range will be given a border
            </summary>
        </member>
        <member name="T:Glaives.Core.Graphics.View">
            <inheritdoc />
            <summary>
            <para>A view is used to project the geometry onto the viewport</para>
            <para>It contains the projection matrix which is used in the vertex shaders to transform the vertices to view-space</para>
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.View.ProjectionMatrix">
            <summary>
            The projection matrix of the current view is passed to the vertex shaders to transform the vertices to view-space
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.View.Center">
            <summary>
            The center of the view
            </summary>
        </member>
        <member name="T:Glaives.Core.Input.InputActionBinding">
            <summary>
            Binding an id to an array of keys
            </summary>
        </member>
        <member name="P:Glaives.Core.Input.InputActionBinding.Id">
            <summary>
            The identifier for this input binding
            </summary>
        </member>
        <member name="P:Glaives.Core.Input.InputActionBinding.Keys">
            <summary>
            The keys associated with this input binding
            </summary>
        </member>
        <member name="T:Glaives.Core.Input.InputAxisScalePair">
            <summary>
            An axis and a scale for the value of that axis
            </summary>
        </member>
        <member name="P:Glaives.Core.Input.InputAxisScalePair.Axis">
            <summary>
            The axis
            </summary>
        </member>
        <member name="P:Glaives.Core.Input.InputAxisScalePair.Scale">
            <summary>
            The value by which to multiply the axis value
            </summary>
        </member>
        <member name="T:Glaives.Core.Input.InputAxisBinding">
            <summary>
            Binding an id to an axis
            </summary>
        </member>
        <member name="P:Glaives.Core.Input.InputAxisBinding.Id">
            <summary>
            The identifier for this input axis binding
            </summary>
        </member>
        <member name="P:Glaives.Core.Input.InputAxisBinding.AxisScalePairs">
            <summary>
            The pairs contain the axes and the scales by which to multiply their values
            </summary>
        </member>
        <member name="M:Glaives.Core.Input.InputBinder.BindAction(System.String,Glaives.Core.Input.InputBinder.InputActionEvent)">
            <summary>
            Bind an input action to a function that handles the input event
            </summary>
            <param name="inputActionId">The id of the input action binding</param>
            <param name="eventHandler">The function that will handle this input action event</param>
        </member>
        <member name="M:Glaives.Core.Input.InputBinder.BindAxis(System.String,Glaives.Core.Input.InputBinder.InputAxisEvent)">
            <summary>
            Bind an input axis to a function that handles the input event
            </summary>
            <param name="inputAxisId">The id of the input axis binding</param>
            <param name="eventHandler">The function that will handle this input axis event</param>
        </member>
        <member name="M:Glaives.Core.Input.InputBinder.UnbindAction(System.String)">
            <summary>
            Unbind a specific action (does nothing if the action is not bound)
            </summary>
            <param name="inputActionId"></param>
        </member>
        <member name="M:Glaives.Core.Input.InputBinder.UnbindAxis(System.String)">
            <summary>
            Unbind a specific axis (does nothing if the axis is not bound)
            </summary>
            <param name="inputAxisId"></param>
        </member>
        <member name="M:Glaives.Core.Input.InputBinder.UnbindAllActions">
            <summary>
            Unbind all actions
            </summary>
        </member>
        <member name="M:Glaives.Core.Input.InputBinder.UnbindAllAxes">
            <summary>
            Unbind all axes
            </summary>
        </member>
        <member name="M:Glaives.Core.Input.InputBinder.UnbindAll">
            <summary>
            Unbind all actions and axes
            </summary>
        </member>
        <member name="F:Glaives.Core.Input.Key.GamepadRightThumbstick">
            <summary>
            The "press" of the thumbstick
            </summary>
        </member>
        <member name="F:Glaives.Core.Input.Key.GamepadLeftThumbstick">
            <summary>
            The "press" of the thumbstick
            </summary>
        </member>
        <member name="F:Glaives.Core.Input.Key.GamepadRightThumbstickX">
            <summary>
            Triggered when the thumbstick's X-axis reaches a threshold
            </summary>
        </member>
        <member name="F:Glaives.Core.Input.Key.GamepadRightThumbstickY">
            <summary>
            Triggered when the thumbstick's Y-axis reaches a threshold
            </summary>
        </member>
        <member name="F:Glaives.Core.Input.Key.GamepadLeftThumbstickX">
            <summary>
            Triggered when the thumbstick's X-axis reaches a threshold
            </summary>
        </member>
        <member name="F:Glaives.Core.Input.Key.GamepadLeftThumbstickY">
            <summary>
            Triggered when the thumbstick's Y-axis reaches a threshold
            </summary>
        </member>
        <member name="F:Glaives.Core.Input.Key.GamepadRightTrigger">
            <summary>
            Triggered when the trigger axis has reached a threshold
            </summary>
        </member>
        <member name="F:Glaives.Core.Input.Key.GamepadLeftTrigger">
            <summary>
            Triggered when the trigger axis has reached a threshold
            </summary>
        </member>
        <member name="M:Glaives.Core.Internal.Content.ContentInfo.GetHashCode">
            <inheritdoc />
        </member>
        <member name="P:Glaives.Core.Internal.Graphics.GeometryBatch.VertexArrayPosition">
            <summary>
            Is the same as the amount of vertices to be drawn by this batch
            </summary>
        </member>
        <member name="M:Glaives.Core.Internal.Graphics.GlyphInfo.Equals(Glaives.Core.Internal.Graphics.GlyphInfo)">
            <inheritdoc />
        </member>
        <member name="M:Glaives.Core.Internal.Graphics.GlyphInfo.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Glaives.Core.Internal.Graphics.GlyphInfo.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:Glaives.Core.Internal.LevelManagment.LevelManager">
            <summary>
            Manages loading and unloading of levels
            </summary>
        </member>
        <member name="P:Glaives.Core.Internal.LevelManagment.LevelManager.Level">
            <summary>
            The level currently loaded 
            </summary>
        </member>
        <member name="M:Glaives.Core.Internal.LevelManagment.LevelManager.LoadLevel``1">
            <summary>
            Unload the current level and load the new level
            </summary>
            <typeparam name="T">The type of the level to load</typeparam>
        </member>
        <member name="M:Glaives.Core.Internal.LevelManagment.LevelManager.LoadLevel(System.Type)">
            <summary>
            Unload the current level and load the new level
            </summary>
            <param name="levelType">The type of the level to load</param>
        </member>
        <member name="P:Glaives.Core.IntVector2.Zero">
            <summary>
            An int vector with X and Y set to 0
            </summary>
        </member>
        <member name="P:Glaives.Core.IntVector2.UnitX">
            <summary>
            An int vector with X set to 1 and Y set to 0
            </summary>
        </member>
        <member name="P:Glaives.Core.IntVector2.UnitY">
            <summary>
            An int vector with X set to 0 and Y set to 1
            </summary>
        </member>
        <member name="P:Glaives.Core.IntVector2.Unit">
            <summary>
            An int vector with X and Y set to 1
            </summary>
        </member>
        <member name="T:Glaives.Core.Level">
            <summary>
            A hierarchy of GameObjects
            </summary>
        </member>
        <member name="P:Glaives.Core.Level.Engine">
            <summary>
            A shorthand to Engine.Get
            </summary>
        </member>
        <member name="P:Glaives.Core.Level.Root">
            <summary>
            The root actor of the level is immutable and will always exist in the level
            </summary>
        </member>
        <member name="P:Glaives.Core.Level.ActorCount">
            <summary>
            The total amount of actors in the level (not including the level root)
            </summary>
        </member>
        <member name="P:Glaives.Core.Level.DefaultView">
            <summary>
            The default view 
            </summary>
        </member>
        <member name="P:Glaives.Core.Level.CurrentView">
            <summary>
            The currently active view
            </summary>
        </member>
        <member name="P:Glaives.Core.Level.IsLoadComplete">
            <summary>
            Whether or not the load level coroutine has finished and all actors have been initialized
            </summary>
        </member>
        <member name="F:Glaives.Core.Level.PendingDestroyActors">
            <summary>
            Actors to be destroyed at the end of the frame
            </summary>
        </member>
        <member name="M:Glaives.Core.Level.BuildHierarchyString">
            <summary>
            A string that represents the level hierarchy
            </summary>
            <returns></returns>
        </member>
        <member name="M:Glaives.Core.Level.LoadLevelCoroutine">
            <summary>
            Load your level content in this coroutine
            </summary>
        </member>
        <member name="M:Glaives.Core.Level.Tick(System.Single)">
            <summary>
            Called every tick 
            </summary>
            <param name="deltaTime">The elapsed time in seconds since the last tick</param>
        </member>
        <member name="M:Glaives.Core.LoadableContent.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Glaives.Core.UniqueString">
            <summary>
            Ensures there is no other UniqueString with the same string value during the same runtime
            Adds a postfix to make the string unique to other UniqueStrings
            </summary>
        </member>
        <member name="F:Glaives.Core.UniqueString.String">
            <summary>
            The unique string
            </summary>
        </member>
        <member name="M:Glaives.Core.UniqueString.#ctor(System.String)">
            <summary>
            Potentially modifies the input str by adding a postfix to ensure it is unique to other UniqueStrings
            </summary>
            <param name="str"></param>
        </member>
        <member name="T:Glaives.Core.Utils.MathEx">
            <summary>
            Additional math utility methods to extend System.Math
            </summary>
        </member>
        <member name="M:Glaives.Core.Utils.MathEx.FastSin(System.Single)">
            <summary>
            Fast sine using a precomputed lookup table
            </summary>
            <param name="radians"></param>
            <returns></returns>
        </member>
        <member name="M:Glaives.Core.Utils.MathEx.FastCos(System.Single)">
            <summary>
            Fast cosine using a precomputed lookup table
            </summary>
            <param name="radians"></param>
            <returns></returns>
        </member>
        <member name="P:Glaives.Core.Vector2.Length">
            <summary>
            The length of the vector
            </summary>
        </member>
        <member name="P:Glaives.Core.Vector2.LengthSquared">
            <summary>
            The square length of the vector (offers better performance than Length)
            </summary>
        </member>
        <member name="M:Glaives.Core.Vector2.Dot(Glaives.Core.Vector2,Glaives.Core.Vector2)">
            <summary>
            Calculate the dot product of 2 vectors
            </summary>
            <param name="left">Input vector a</param>
            <param name="right">Input vector b</param>
            <returns>The dot product</returns>
        </member>
        <member name="M:Glaives.Core.Vector2.Lerp(Glaives.Core.Vector2,Glaives.Core.Vector2,System.Single)">
            <summary>
            Calculate the linearly interpolated vector
            </summary>
            <param name="a">Input vector a</param>
            <param name="b">Input vector b</param>
            <param name="alpha">The amount of interpolation</param>
            <returns>The interpolated vector</returns>
        </member>
        <member name="M:Glaives.Core.Vector2.Normalize(Glaives.Core.Vector2)">
            <summary>
            Scale the vector to unit length
            </summary>
            <param name="vector">The input vector</param>
            <returns>The normalized vector</returns>
        </member>
        <member name="P:Glaives.Core.Vector2.Unit">
            <summary>
            A vector2 with X and Y set to 1
            </summary>
        </member>
        <member name="P:Glaives.Core.Vector2.UnitX">
            <summary>
            A vector2 with X set to 1 and Y set to 0
            </summary>
        </member>
        <member name="P:Glaives.Core.Vector2.UnitY">
            <summary>
            A vector2 with X set to 0 and Y set to 1
            </summary>
        </member>
        <member name="P:Glaives.Core.Vector2.Zero">
            <summary>
            A vector2 with X and Y set to 0
            </summary>
        </member>
        <member name="M:SDL2.SDL.SDL_GetNumTouchDevices">
            \brief Get the number of registered touch devices.
        </member>
        <member name="M:SDL2.SDL.SDL_GetTouchDevice(System.Int32)">
            \brief Get the touch ID with the given index, or 0 if the index is invalid.
        </member>
        <member name="M:SDL2.SDL.SDL_GetNumTouchFingers(System.Int64)">
            \brief Get the number of active fingers for a given touch device.
        </member>
        <member name="M:SDL2.SDL.SDL_GetTouchFinger(System.Int64,System.Int32)">
            \brief Get the finger object of the given touch, with the given index.
            Returns pointer to SDL_Finger.
        </member>
    </members>
</doc>
