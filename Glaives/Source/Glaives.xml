<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Glaives</name>
    </assembly>
    <members>
        <member name="T:Glaives.Core.Actor">
            <summary>
            Base class for any object that is part of a level hierarchy and can be transformed
            </summary>
        </member>
        <member name="P:Glaives.Core.Actor.Name">
            <summary>
            The unique name of the actor
            </summary>
        </member>
        <member name="P:Glaives.Core.Actor.Children">
            <summary>
            Enumerates the children for this actor (no sub-children)
            </summary>
        </member>
        <member name="P:Glaives.Core.Actor.Parent">
            <summary>
            Parent the actor to another actor (cannot be null, use Unparent to parent the actor to the level root)
            </summary>
        </member>
        <member name="P:Glaives.Core.Actor.LocalPosition">
            <summary>
            The position in local space
            </summary>
        </member>
        <member name="P:Glaives.Core.Actor.LocalRotation">
            <summary>
            The rotation in local space
            </summary>
        </member>
        <member name="P:Glaives.Core.Actor.LocalScale">
            <summary>
            
            </summary>
        </member>
        <member name="P:Glaives.Core.Actor.Position">
            <summary>
            The position in world space
            </summary>
        </member>
        <member name="P:Glaives.Core.Actor.Rotation">
            <summary>
            The rotation in world space
            </summary>
        </member>
        <member name="P:Glaives.Core.Actor.Scale">
            <summary>
            The scale in world space
            </summary>
        </member>
        <member name="P:Glaives.Core.Actor.Up">
            <summary>
            The up vector
            </summary>
        </member>
        <member name="P:Glaives.Core.Actor.Right">
            <summary>
            The right vector
            </summary>
        </member>
        <member name="P:Glaives.Core.Actor.LocalMatrix">
            <summary>
            The local space matrix
            </summary>
        </member>
        <member name="P:Glaives.Core.Actor.WorldMatrix">
            <summary>
            The world space matrix
            </summary>
        </member>
        <member name="P:Glaives.Core.Actor.InverseWorldMatrix">
            <summary>
            The inverse world space matrix
            </summary>
        </member>
        <member name="P:Glaives.Core.Actor.InputEnabled">
            <summary>
            Whether or not the actor should receive input events
            </summary>
        </member>
        <member name="P:Glaives.Core.Actor.Engine">
            <summary>
            A shorthand to the engine singleton
            </summary>
        </member>
        <member name="P:Glaives.Core.Actor.CoroutineRunner">
            <summary>
            The coroutine runner for this actor
            </summary>
        </member>
        <member name="P:Glaives.Core.Actor.InputBinder">
            <summary>
            <para>Contains functionality for binding input to function handlers</para>
            <para>Each actor has it's own input binder</para>
            </summary>
        </member>
        <member name="F:Glaives.Core.Actor.Immutable">
            <summary>
            Whether or not the actor can be re-parented or destroyed (internal use only)
            </summary>
        </member>
        <member name="M:Glaives.Core.Actor.#ctor">
            <inheritdoc />
        </member>
        <member name="M:Glaives.Core.Actor.DoRecursive(System.Action{Glaives.Core.Actor},System.Boolean)">
            <summary>
            Performs an action recursively for actors under this actor in the hierarchy (and self if includeSelf = true)
            </summary>
            <param name="action"></param>
            <param name="includeSelf">Wheter or not we should perform this action on ourself as well</param>
            <returns>The amount of actors the action was operated on</returns>
        </member>
        <member name="M:Glaives.Core.Actor.Unparent">
            <summary>
            Parent the actor to the level root
            </summary>
        </member>
        <member name="M:Glaives.Core.Actor.Destroy">
            <summary>
            <para>Marks this actor for destroy and it's children recursively</para>
            <para>Marked actors will be destroyed at the end of the frame</para>
            </summary>
        </member>
        <member name="M:Glaives.Core.Actor.ForceDestroy">
            <summary>
            Destroy even when immutable (used to unload levels)
            </summary>
        </member>
        <member name="M:Glaives.Core.Actor.SetParentInternal(Glaives.Core.Actor)">
            <summary>
            This is only part of the Parent.Set code, Do not call this function from outside the Parent.Set
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Glaives.Core.Actor.Initialize">
            <summary>
            Called after the load level coroutine is completed or immediately if the actor is created after level loading 
            </summary>
        </member>
        <member name="M:Glaives.Core.Actor.Tick(System.Single)">
            <summary>
            Called every tick
            </summary>
            <param name="deltaTime">The elapsed time in seconds since the last tick</param>
        </member>
        <member name="M:Glaives.Core.Actor.ReceiveInputAction(Glaives.Core.Input.KeyState,Glaives.Core.Input.Key,System.Int32)">
            <summary>
            Process an input event if input is enabled for this actor
            </summary>
            <param name="keyState"></param>
            <param name="key">The key that triggered this event</param>
            <param name="gamepadId">The id of the gamepad that triggered this event (if it is triggered by a gamepad)</param>
        </member>
        <member name="M:Glaives.Core.Actor.ReceiveInputAxis(Glaives.Core.Input.InputAxis,System.Single,System.Int32)">
            <summary>
            Process an input axis event if input is enabled for this actor
            </summary>
            <param name="axis">The axis</param>
            <param name="value">The value of the axis (can be between 0 and 1 or -1 and 1 depending on the type of axis)</param>
            <param name="gamepadId">The id of the gamepad that triggered this event (if it is triggered by a gamepad)</param>
        </member>
        <member name="T:Glaives.Core.Configuration.GeneralSettings">
            <summary>
            General engine settings
            </summary>
        </member>
        <member name="P:Glaives.Core.Configuration.ImGuiSettings.Theme">
            <summary>
            The appearance style of ImGui
            </summary>
        </member>
        <member name="P:Glaives.Core.Configuration.ImGuiSettings.Alpha">
            <summary>
            The overall alpha used together with the theme
            </summary>
        </member>
        <member name="T:Glaives.Core.Configuration.InputSettings">
            <summary>
            Engine settings related to input
            </summary>
        </member>
        <member name="P:Glaives.Core.Configuration.InputSettings.ActionBindings">
            <summary>
            The input action bindings
            </summary>
        </member>
        <member name="P:Glaives.Core.Configuration.InputSettings.AxisBindings">
            <summary>
            The input axis bindings
            </summary>
        </member>
        <member name="M:Glaives.Core.Configuration.InputSettings.GetDeadzoneForAxis(Glaives.Core.Input.InputAxis)">
            <summary>
            The deadzone for a specified axis
            </summary>
            <param name="axis"></param>
            <returns></returns>
        </member>
        <member name="T:Glaives.Core.Configuration.Settings">
            <summary>
            Root class for all engine settings
            </summary>
        </member>
        <member name="M:Glaives.Core.Configuration.Settings.Save(System.String)">
            <summary>
            Serialize the settings to an XML file
            </summary>
            <param name="settingsPath"></param>
        </member>
        <member name="M:Glaives.Core.Configuration.Settings.FromFile(System.String)">
            <summary>
            Load the settings from an XML file
            </summary>
            <param name="settingsFile">The XML file which contains the settings</param>
        </member>
        <member name="T:Glaives.Core.Configuration.VideoSettings">
            <summary>
            Engine settings related to windowing and graphics
            </summary>
        </member>
        <member name="P:Glaives.Core.Configuration.VideoSettings.Width">
            <summary>
            The width of the window
            </summary>
        </member>
        <member name="P:Glaives.Core.Configuration.VideoSettings.Height">
            <summary>
            The height of the window
            </summary>
        </member>
        <member name="P:Glaives.Core.Configuration.VideoSettings.Title">
            <summary>
            The title of the window
            </summary>
        </member>
        <member name="P:Glaives.Core.Configuration.VideoSettings.VSync">
            <summary>
            Whether or not the window should use vertical synchronization
            </summary>
        </member>
        <member name="P:Glaives.Core.Configuration.VideoSettings.TargetFps">
            <summary>
            <para>The desired frames per second</para>
            <para>This is an approximation, actual fps may vary</para>
            <para>0 means unlimited</para>
            </summary>
        </member>
        <member name="T:Glaives.Core.ContentCreateOptions">
            <summary>
            Base class for any content create options
            </summary>
        </member>
        <member name="M:Glaives.Core.ContentCreateOptions.IsEqualContent(Glaives.Core.ContentCreateOptions)">
            <summary>
            Whether or not the content create options are identical
            This check avoids duplicate content loading
            </summary>
            <param name="otherContent">The other content create options</param>
        </member>
        <member name="T:Glaives.Core.ContentLoader">
            <summary>
            <para>Loads and caches content files</para>
            <para>When loading content, the content loader will first check if this file was loaded previously (with the same create options)</para>
            <para>If it is present in the content cache it will return the cached content, otherwise it will load it and add it to the content cache</para>
            </summary>
        </member>
        <member name="M:Glaives.Core.ContentLoader.LoadFont(System.String,Glaives.Core.Graphics.FontCreateOptions)">
            <summary>
            Load a font file (supported formats: TTF and OTF)
            </summary>
            <param name="file">The font file</param>
            <param name="createOptions">The create options used to load the font</param>
            <returns></returns>
        </member>
        <member name="M:Glaives.Core.ContentLoader.LoadTexture(System.String,Glaives.Core.Graphics.TextureCreateOptions)">
            <summary>
            Load a texture (supported formats: Png, Jpeg, Bmp and Gif)
            </summary>
            <param name="file">The texture file to load</param>
            <param name="createOptions">The create options used to load the texture</param>
            <returns></returns>
        </member>
        <member name="M:Glaives.Core.ContentLoader.LoadShader(System.String,System.String)">
            <summary>
            Return loaded or cached shader
            </summary>
            <param name="vertexShaderFile">The vertex shader file to load</param>
            <param name="fragmentShaderFile">The fragment shader file to load</param>
            <returns>The shader</returns>
        </member>
        <member name="M:Glaives.Core.ContentLoader.DisposeAllContent">
            <summary>
            Disposes all cached content
            </summary>
        </member>
        <member name="T:Glaives.Core.Coroutines.Coroutine">
            <summary>
            <para>A coroutine contains the routine and it's callbacks</para>
            <para>Also provides static utility methods for yield operations</para>
            </summary>
        </member>
        <member name="F:Glaives.Core.Coroutines.Coroutine.Routine">
            <summary>
            The running routine
            </summary>
        </member>
        <member name="F:Glaives.Core.Coroutines.Coroutine.CompletedCallback">
            <summary>
            The callback that gets invoked when the routine terminates or is stopped
            </summary>
        </member>
        <member name="M:Glaives.Core.Coroutines.Coroutine.WaitForSeconds(System.Single)">
            <summary>
            Yield return this method in a coroutine to make it wait for a specified amount of seconds
            before continuing past the yield 
            </summary>
            <param name="seconds">The amount of seconds to wait</param>
        </member>
        <member name="M:Glaives.Core.Coroutines.Coroutine.WaitForTicks(System.UInt32)">
            <summary>
            Yield return this method in a coroutine to make it wait for a specified amount of ticks
            before continuing past the yield
            </summary>
            <param name="ticks">The amount of ticks to wait</param>
        </member>
        <member name="T:Glaives.Core.Coroutines.CoroutineCallbacks">
            <summary>
            A collection of delegate declarations associated with coroutines
            </summary>
        </member>
        <member name="T:Glaives.Core.Coroutines.CoroutineCallbacks.CoroutineCompletedCallback">
            <summary>
            The delegate declaration of the coroutine completed callback
            </summary>
        </member>
        <member name="T:Glaives.Core.Coroutines.CoroutineRunner">
            <summary>
            Runs and stops coroutines
            </summary>
        </member>
        <member name="P:Glaives.Core.Coroutines.CoroutineRunner.RunningCoroutines">
            <summary>
            The coroutines that are currently running on this coroutine runner
            </summary>
        </member>
        <member name="M:Glaives.Core.Coroutines.CoroutineRunner.RunCoroutine(System.Collections.IEnumerator,Glaives.Core.Coroutines.CoroutineCallbacks.CoroutineCompletedCallback)">
            <summary>
            Run a new coroutine
            </summary>
            <param name="routine">The routine to run</param>
            <param name="completedCallback">The callback will be called after the routine has either terminates or is stopped</param>
        </member>
        <member name="M:Glaives.Core.Coroutines.CoroutineRunner.StopCoroutine(System.Collections.IEnumerator)">
            <summary>
            Stop a running routine
            </summary>
            <param name="routine">The routine to stop (does nothing if the routine is not running)</param>
        </member>
        <member name="M:Glaives.Core.Coroutines.CoroutineRunner.StopAllCoroutines">
            <summary>
            Stop all coroutines associated with this coroutine runner
            </summary>
        </member>
        <member name="M:Glaives.Core.Diagnostics.Debugger.Info(System.Object)">
            <summary>
            <para>Log an information message (something non-problematic)</para>
            <para>Will not be included in the error log file</para>
            </summary>
            <param name="infoMessage"></param>
        </member>
        <member name="M:Glaives.Core.Diagnostics.Debugger.Warning(System.Object)">
            <summary>
            <para>Log a warning message (something potentially problematic)</para>
            <para>Will be included in the error log file</para>
            </summary>
            <param name="warningMessage"></param>
        </member>
        <member name="M:Glaives.Core.Diagnostics.Debugger.Error(System.Object)">
            <summary>
            <para>Log an error message (something critically problematic)</para>
            <para>Will be included in the error log file</para>
            </summary>
            <param name="errorMessage"></param>
        </member>
        <member name="T:Glaives.Core.Diagnostics.LogType">
            <summary>
            The type of log message
            </summary>
        </member>
        <member name="F:Glaives.Core.Diagnostics.LogType.Info">
            <summary>
            An info log is non-problematic message
            </summary>
        </member>
        <member name="F:Glaives.Core.Diagnostics.LogType.Warning">
            <summary>
            A warning log is a message about something which is could cause issues
            </summary>
        </member>
        <member name="F:Glaives.Core.Diagnostics.LogType.Error">
            <summary>
            An error log is a message about something that is a critical, application breaking issue
            </summary>
        </member>
        <member name="P:Glaives.Core.Diagnostics.Statistics.Fps">
            <summary>
            The current frame rate 
            </summary>
        </member>
        <member name="T:Glaives.Core.Engine">
            <summary>
            The service provider for all engine features
            </summary>
        </member>
        <member name="P:Glaives.Core.Engine.Get">
            <summary>
            Get the engine singleton
            </summary>
        </member>
        <member name="P:Glaives.Core.Engine.Settings">
            <summary>
            Contains all project-specific engine settings
            </summary>
        </member>
        <member name="P:Glaives.Core.Engine.Stats">
            <summary>
            Engine statistics
            </summary>
        </member>
        <member name="P:Glaives.Core.Engine.GameInstance">
            <summary>
            The game instance
            </summary>
        </member>
        <member name="P:Glaives.Core.Engine.Debug">
            <summary>
            Debug utility
            </summary>
        </member>
        <member name="P:Glaives.Core.Engine.Content">
            <summary>
            <para>Loads and caches content files</para>
            <para>When loading content, the content loader will first check if this file was loaded previously</para>
            <para>If it is present in the content cache it will return the cached content, otherwise it will load it and add it to the content cache</para>
            </summary>
        </member>
        <member name="P:Glaives.Core.Engine.Graphics">
            <summary>
            Contains rendering-related functionality
            </summary>
        </member>
        <member name="P:Glaives.Core.Engine.Viewport">
            <summary>
            The viewport of the window
            </summary>
        </member>
        <member name="P:Glaives.Core.Engine.ContentFolder">
            <summary>
            The path to the content root directory
            </summary>
        </member>
        <member name="P:Glaives.Core.Engine.WindowHandle">
            <summary>
            The handle to the native window
            </summary>
        </member>
        <member name="P:Glaives.Core.Engine.CurrentLevel">
            <summary>
            The currently loaded level
            </summary>
        </member>
        <member name="P:Glaives.Core.Engine.RenderImGui">
            <summary>
            Whether or not we should render ImGui stuff
            </summary>
        </member>
        <member name="P:Glaives.Core.Engine.ShowImGuiGlaivesMenuBar">
            <summary>
            Whether or not we should show the default main menu bar and it's contents
            </summary>
        </member>
        <member name="M:Glaives.Core.Engine.Initialize``2(System.String)">
            <summary>
            Initializes all modules and loads the initial level
            </summary>
            <typeparam name="TGameInstanceType">The type of your custom game instance (create a class and inherit from GameInstance)</typeparam>
            <typeparam name="TInitialLevelType">The type of your custom level to load as the first level (create a class and inherit from Level)</typeparam>
            <param name="contentFolder">The relative path to your content root folder</param>
        </member>
        <member name="M:Glaives.Core.Engine.Initialize(System.Type,System.Type,System.String)">
            <summary>
            Initializes all modules and loads the initial level
            </summary>
            <param name="gameInstanceType">The type of your custom game instance (create a class and inherit from GameInstance)</param>
            <param name="initialLevelType">The type of your custom level to load as the first level (create a class and inherit from Level)</param>
            <param name="contentFolder">The relative path to your content root folder</param>
        </member>
        <member name="M:Glaives.Core.Engine.LoadLevel``1">
            <summary>
            Load a new level and unload the current one
            </summary>
            <typeparam name="TLevel">The level type</typeparam>
        </member>
        <member name="M:Glaives.Core.Engine.LoadLevel(System.Type)">
            <summary>
            Load a new level and unload the current one
            </summary>
            <param name="levelType">The level type (must derive from Level)</param>
        </member>
        <member name="M:Glaives.Core.Engine.Quit">
            <summary>
            Quit the game and close the window
            </summary>
        </member>
        <member name="M:Glaives.Core.Engine.OnActorConstruction(Glaives.Core.Actor)">
            <summary>
            Called in the actor constructor
            </summary>
            <param name="newActor"></param>
        </member>
        <member name="T:Glaives.Core.GameInstance">
            <summary>
            A game instance is a persistent class that will exist until the program closes
            </summary>
        </member>
        <member name="P:Glaives.Core.GameInstance.Engine">
            <summary>
            A shorthand to the engine singleton
            </summary>
        </member>
        <member name="M:Glaives.Core.GameInstance.InitializeSettings">
            <summary>
            <para>The engine will obtain it's settings from this call when it initializes</para>
            <para>Called once before Initialize</para>
            </summary>  
            <returns>The settings you want to use for the application</returns>
        </member>
        <member name="M:Glaives.Core.GameInstance.Initialize">
            <summary>
            Called after the engine modules have been initialized
            </summary>
        </member>
        <member name="M:Glaives.Core.GameInstance.OnImGui">
            <summary>
            ImGui rendering 
            </summary>
        </member>
        <member name="M:Glaives.Core.GameInstance.ReceiveLogs(Glaives.Core.Diagnostics.LogType,System.String,System.String,System.String,System.Int32)">
            <summary>
            Receive engine log messages
            </summary>
            <param name="logType">The type of log message</param>
            <param name="message">The log message</param>
            <param name="className">The class which invoked this log</param>
            <param name="methodName">The method in the class which invoked this log</param>
            <param name="lineNumber">The number of the line in the method that invoked this log</param>
        </member>
        <member name="F:Glaives.Core.Graphics.BlendMode.Factor.Zero">
            <summary>(0, 0, 0, 0)</summary>
        </member>
        <member name="F:Glaives.Core.Graphics.BlendMode.Factor.One">
            <summary>(1, 1, 1, 1)</summary>
        </member>
        <member name="F:Glaives.Core.Graphics.BlendMode.Factor.SrcColor">
            <summary>(src.r, src.g, src.b, src.a)</summary>
        </member>
        <member name="F:Glaives.Core.Graphics.BlendMode.Factor.OneMinusSrcColor">
            <summary>(1, 1, 1, 1) - (src.r, src.g, src.b, src.a)</summary>
        </member>
        <member name="F:Glaives.Core.Graphics.BlendMode.Factor.DstColor">
            <summary>(dst.r, dst.g, dst.b, dst.a)</summary>
        </member>
        <member name="F:Glaives.Core.Graphics.BlendMode.Factor.OneMinusDstColor">
            <summary>(1, 1, 1, 1) - (dst.r, dst.g, dst.b, dst.a)</summary>
        </member>
        <member name="F:Glaives.Core.Graphics.BlendMode.Factor.SrcAlpha">
            <summary>(src.a, src.a, src.a, src.a)</summary>
        </member>
        <member name="F:Glaives.Core.Graphics.BlendMode.Factor.OneMinusSrcAlpha">
            <summary>(1, 1, 1, 1) - (src.a, src.a, src.a, src.a)</summary>
        </member>
        <member name="F:Glaives.Core.Graphics.BlendMode.Factor.DstAlpha">
            <summary>(dst.a, dst.a, dst.a, dst.a)</summary>
        </member>
        <member name="F:Glaives.Core.Graphics.BlendMode.Factor.OneMinusDstAlpha">
            <summary>(1, 1, 1, 1) - (dst.a, dst.a, dst.a, dst.a)</summary>
        </member>
        <member name="T:Glaives.Core.Graphics.BlendMode.Equation">
            <summary>
            Enumeration of the blending equations
            </summary>
        </member>
        <member name="F:Glaives.Core.Graphics.BlendMode.Equation.Add">
            <summary>Pixel = Src * SrcFactor + Dst * DstFactor</summary>
        </member>
        <member name="F:Glaives.Core.Graphics.BlendMode.Equation.Subtract">
            <summary>Pixel = Src * SrcFactor - Dst * DstFactor</summary>
        </member>
        <member name="F:Glaives.Core.Graphics.BlendMode.Alpha">
            <summary>Blend source and dest according to dest alpha</summary>
        </member>
        <member name="F:Glaives.Core.Graphics.BlendMode.Add">
            <summary>Add source to dest</summary>
        </member>
        <member name="F:Glaives.Core.Graphics.BlendMode.Multiply">
            <summary>Multiply source and dest</summary>
        </member>
        <member name="F:Glaives.Core.Graphics.BlendMode.None">
            <summary>Overwrite dest with source</summary>
        </member>
        <member name="F:Glaives.Core.Graphics.BlendMode.ColorSrcFactor">
            <summary>Source blending factor for the color channels</summary>
        </member>
        <member name="F:Glaives.Core.Graphics.BlendMode.ColorDstFactor">
            <summary>Destination blending factor for the color channels</summary>
        </member>
        <member name="F:Glaives.Core.Graphics.BlendMode.ColorEquation">
            <summary>Blending equation for the color channels</summary>
        </member>
        <member name="F:Glaives.Core.Graphics.BlendMode.AlphaSrcFactor">
            <summary>Source blending factor for the alpha channel</summary>
        </member>
        <member name="F:Glaives.Core.Graphics.BlendMode.AlphaDstFactor">
            <summary>Destination blending factor for the alpha channel</summary>
        </member>
        <member name="F:Glaives.Core.Graphics.BlendMode.AlphaEquation">
            <summary>Blending equation for the alpha channel</summary>
        </member>
        <member name="M:Glaives.Core.Graphics.BlendMode.#ctor(Glaives.Core.Graphics.BlendMode.Factor,Glaives.Core.Graphics.BlendMode.Factor)">
            <summary>
            Construct the blend mode given the factors and equation
            </summary>
            <param name="sourceFactor">Specifies how to compute the source factor for the color and alpha channels.</param>
            <param name="destinationFactor">Specifies how to compute the destination factor for the color and alpha channels.</param>
        </member>
        <member name="M:Glaives.Core.Graphics.BlendMode.#ctor(Glaives.Core.Graphics.BlendMode.Factor,Glaives.Core.Graphics.BlendMode.Factor,Glaives.Core.Graphics.BlendMode.Equation)">
            <summary>
            Construct the blend mode given the factors and equation
            </summary>
            <param name="sourceFactor">Specifies how to compute the source factor for the color and alpha channels.</param>
            <param name="destinationFactor">Specifies how to compute the destination factor for the color and alpha channels.</param>
            <param name="blendEquation">Specifies how to combine the source and destination colors and alpha.</param>
        </member>
        <member name="M:Glaives.Core.Graphics.BlendMode.#ctor(Glaives.Core.Graphics.BlendMode.Factor,Glaives.Core.Graphics.BlendMode.Factor,Glaives.Core.Graphics.BlendMode.Equation,Glaives.Core.Graphics.BlendMode.Factor,Glaives.Core.Graphics.BlendMode.Factor,Glaives.Core.Graphics.BlendMode.Equation)">
            <summary>
            Construct the blend mode given the factors and equation
            </summary>
            <param name="colorSourceFactor">Specifies how to compute the source factor for the color channels.</param>
            <param name="colorDestinationFactor">Specifies how to compute the destination factor for the color channels.</param>
            <param name="colorBlendEquation">Specifies how to combine the source and destination colors.</param>
            <param name="alphaSourceFactor">Specifies how to compute the source factor.</param>
            <param name="alphaDestinationFactor">Specifies how to compute the destination factor.</param>
            <param name="alphaBlendEquation">Specifies how to combine the source and destination alphas.</param>
        </member>
        <member name="M:Glaives.Core.Graphics.BlendMode.op_Equality(Glaives.Core.Graphics.BlendMode,Glaives.Core.Graphics.BlendMode)">
            <summary>
            Compare two blend modes and checks if they are equal
            </summary>
            <returns>Blend Modes are equal</returns>
        </member>
        <member name="M:Glaives.Core.Graphics.BlendMode.op_Inequality(Glaives.Core.Graphics.BlendMode,Glaives.Core.Graphics.BlendMode)">
            <summary>
            Compare two blend modes and checks if they are not equal
            </summary>
            <returns>Blend Modes are not equal</returns>
        </member>
        <member name="M:Glaives.Core.Graphics.BlendMode.Equals(System.Object)">
            <summary>
            Compare blend mode and object and checks if they are equal
            </summary>
            <param name="obj">Object to check</param>
            <returns>Object and blend mode are equal</returns>
        </member>
        <member name="M:Glaives.Core.Graphics.BlendMode.Equals(Glaives.Core.Graphics.BlendMode)">
            <summary>
            Compare two blend modes and checks if they are equal
            </summary>
            <param name="other">Blend Mode to check</param>
            <returns>blend modes are equal</returns>
        </member>
        <member name="M:Glaives.Core.Graphics.BlendMode.GetHashCode">
            <summary>
            Provide a integer describing the object
            </summary>
            <returns>Integer description of the object</returns>
        </member>
        <member name="P:Glaives.Core.Graphics.Color.White">
            <summary>
            (R=1, G=1, B=1, A=1);
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.Color.Black">
            <summary>
            (R=0, G=0, B=0, A=1);
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.Color.Red">
            <summary>
            (R=1, G=0, B=0, A=1);
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.Color.Green">
            <summary>
            (R=0, G=1, B=0, A=1);
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.Color.Blue">
            <summary>
            (R=0, G=0, B=1, A=1);
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.Color.Magenta">
            <summary>
            (R=1, G=0, B=1, A=1);
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.Color.Transparent">
            <summary>
            (R=0, G=0, B=0, A=0);
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.Color.Grey">
            <summary>
            (R=0.5, G=0.5, B=0.5, A=1);
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.Color.Yellow">
            <summary>
            (R=1, G=1, B=0, A=1);
            </summary>
        </member>
        <member name="M:Glaives.Core.Graphics.Color.ToRgbaBytes">
            <summary>
            Create a byte array of rgba values (between 0 and 255)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Glaives.Core.Graphics.Color.RgbaToBgra(System.Byte[])">
            <summary>
            Convert a RGBA byte array to a BGRA byte array
            </summary>
            <param name="rgbaBytes">The bytes in RGBA order</param>
        </member>
        <member name="M:Glaives.Core.Graphics.Color.BgraToRgba(System.Byte[])">
            <summary>
            Convert a BGRA byte array to a RGBA byte array
            </summary>
            <param name="bgraBytes">The bytes in BGRA order</param>
        </member>
        <member name="M:Glaives.Core.Graphics.Color.RgbaToRgb(System.Byte[])">
            <summary>
            Convert a RGBA byte array to a RGB byte array
            </summary>
            <param name="rgbaBytes">The RGBA bytes</param>
        </member>
        <member name="M:Glaives.Core.Graphics.Color.RgbToRgba(System.Byte[],System.Byte)">
            <summary>
            Convert a RGB byte array to a RGBA byte array
            </summary>
            <param name="rgbBytes">The RGB bytes</param>
            <param name="alpha">The value to use for the alpha channel</param>
        </member>
        <member name="M:Glaives.Core.Graphics.ColorExtensions.ToBytes(System.Collections.Generic.IEnumerable{Glaives.Core.Graphics.Color})">
            <summary>
            <para>Create an RGBA byte array of rgba values (between 0 and 255)</para>
            <para>The RGBA byte array will be 4 times the length of the color collection</para>
            </summary>
            <param name="colors">The colors to convert to RGBA bytes</param>
            <returns>The RGBA bytes</returns>
        </member>
        <member name="M:Glaives.Core.Graphics.ColorExtensions.ToColors(System.Collections.Generic.IEnumerable{System.Byte})">
            <summary>
            <para>Convert the RGBA bytes to colors</para>
            <para>The color array will be a quarter the length of the byte array</para>
            </summary>
            <param name="bytes">The RGBA bytes to convert</param>
            <returns>The colors</returns>
        </member>
        <member name="T:Glaives.Core.Graphics.DrawableActor">
            <inheritdoc />
            <summary>
            <para>An actor that contains geometry that can be drawn</para>
            <para>You can create your own drawable actor by inheriting from drawable actor and implementing the necessary methods</para>
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.DrawableActor.Opacity">
            <summary>
            How transparent this actor is (between 0 and 1)
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.DrawableActor.Color">
            <summary>
            The RGBA color of this actor
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.DrawableActor.LocalBounds">
            <summary>
            <para>The bounds of this drawable actor in local space</para>
            <para>Ignores the transformations (translation, rotation ,scale) that are applied</para>
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.DrawableActor.Origin">
            <summary>
            The normalized origin of the actor (between (0, 0) and (1, 1))
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.DrawableActor.BlendMode">
            <summary>
            The blending modes to use for this drawable actor
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.DrawableActor.Shader">
            <summary>
            The shader to use for this drawable actor
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.DrawableActor.Texture">
            <summary>
            The texture of this drawable actor
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.DrawableActor.DrawLayer">
            <summary>
            The draw layers manage the order at which the drawable actors are drawn (higher layers will overlap lower layers)
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.DrawableActor.Bounds">
            <summary>
            <para>The global bounds of this drawable actor</para>
            <para>Takes into account the transformations (translation, rotation, scale) that are applied</para>
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.DrawableActor.LocalBoundsInternal">
            <summary>
            Internal use for the Actor base class only
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.DrawableActor.OriginInternal">
            <summary>
            Internal use for the Actor base class only
            </summary>
        </member>
        <member name="M:Glaives.Core.Graphics.DrawableActor.Transformed">
            <inheritdoc />
        </member>
        <member name="M:Glaives.Core.Graphics.DrawableActor.ReconstructVertices">
            <summary>
            <para>Marks the vertices as dirty, FillVertexArray will be called again by the GraphicsDevice in the render stage</para>
            <para>Construction will always happen initially when the drawable actor is created</para>
            <para>Call when a change was made that affects the vertices</para>
            <para>Transformational changes (Position, Rotation, Scale), Color and Flips will automatically cause the vertices to be re-constructed</para>
            </summary>
        </member>
        <member name="M:Glaives.Core.Graphics.DrawableActor.FillVertexArray(Glaives.Core.Graphics.Vertex[]@)">
            <summary>
            <para>Do not CALL this function ever, it is merely meant to implement</para>
            <para>Defines the geometry of the drawable actor</para>
            <para>Fill the vertex array (vertices) in this function</para>
            <para>Tip: don't re-create or resize the vertex array when it is not needed (to minimize CPU usage and GC collections)</para>
            </summary>
            <returns></returns>
        </member>
        <member name="T:Glaives.Core.Graphics.DynamicTexture">
            <inheritdoc />
            <summary>
            <para>Unlike a normal texture, a dynamic texture has direct access to it's pixel data</para>
            <para>Use a dynamic texture if you need flexible access to read and write pixel data</para>
            <para>A dynamic texture can be convert to a normal texture and vise-versa (do not forget to dispose the dynamic texture when you are done with it)</para>
            <para>Supported formats: Png, Jpeg, Bmp and Gif</para>
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.DynamicTexture.Size">
            <summary>
            The dimensions of the dynamic texture
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.DynamicTexture.Ptr">
            <summary>
            The pixel data pointer
            </summary>
        </member>
        <member name="M:Glaives.Core.Graphics.DynamicTexture.#ctor(System.String)">
            <summary>
            Load a dynamic texture (supported formats: Png, Jpeg, Bmp and Gif)
            </summary>
            <param name="file">The path to the file (with extension)</param>
        </member>
        <member name="M:Glaives.Core.Graphics.DynamicTexture.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a new dynamic texture
            </summary>
            <param name="width">The width of the dynamic texture</param>
            <param name="height">The height of the dynamic texture</param>
        </member>
        <member name="M:Glaives.Core.Graphics.DynamicTexture.#ctor(Glaives.Core.Graphics.Texture)">
            <summary>
            Create a new dynamic texture 
            </summary>
            <param name="texture">A texture to copy the pixel data from</param>
        </member>
        <member name="M:Glaives.Core.Graphics.DynamicTexture.ReadColors">
            <summary>
            <para>Read the RGBA bytes from the dynamic texture and convert them to colors</para>
            <para>The length of the color array is (Size.X * Size.Y)</para>
            </summary>
            <returns>The pixels as colors</returns>
        </member>
        <member name="M:Glaives.Core.Graphics.DynamicTexture.ReadBytes">
            <summary>
            <para>Read all the RGBA bytes from the dynamic texture</para>
            <para>The length of the byte array is (Size.X * Size.Y * 4)</para>
            </summary>
            <returns>The pixels as RGBA bytes</returns>
        </member>
        <member name="M:Glaives.Core.Graphics.DynamicTexture.ReadColors(Glaives.Core.IntRect)">
            <summary>
            <para>Read the RGBA bytes from the dynamic texture and convert them to colors</para>
            <para>The length of the color array will be (region.Width * region.Height) unless a part of the region falls of the texture, 
            the region will then size down to fit the texture exactly</para>
            </summary>
            <param name="region">The region on the dynamic texture to read from</param>
            <returns>The pixels as colors</returns>
        </member>
        <member name="M:Glaives.Core.Graphics.DynamicTexture.ReadBytes(Glaives.Core.IntRect)">
            <summary>
            <para>Read the RGBA bytes from the dynamic texture</para>
            <para>The length of the byte array will be (region.Width * region.Height * 4) unless a part of the region falls of the texture, 
            the region will then size down to fit the texture exactly</para>
            </summary>
            <param name="region">The region on the dynamic texture to read from</param>
            <returns>The pixels as RGBA bytes</returns>
        </member>
        <member name="M:Glaives.Core.Graphics.DynamicTexture.WriteBytes(System.Byte[])">
            <summary>
            <para>Write RGBA bytes to the dynamic texture</para>
            </summary>
            <param name="bytes">The RGBA bytes to write</param>
        </member>
        <member name="M:Glaives.Core.Graphics.DynamicTexture.WriteColors(Glaives.Core.Graphics.Color[])">
            <summary>
            <para>Write the colors to the dynamic texture</para>
            </summary>
            <param name="colors">The colors to write</param>
        </member>
        <member name="M:Glaives.Core.Graphics.DynamicTexture.WriteColors(Glaives.Core.Graphics.Color[],Glaives.Core.IntRect)">
            <summary>
            <para>Write the colors to the dynamic texture in the specified region</para>
            </summary>
            <param name="colors">The colors to write</param>
            <param name="region">The region on the dynamic texture to write into</param>
        </member>
        <member name="M:Glaives.Core.Graphics.DynamicTexture.WriteColor(Glaives.Core.Graphics.Color,Glaives.Core.IntRect)">
            <summary>
            <para>Write a single color into all pixels in the region</para>
            </summary>
            <param name="color">The color to write</param>
            <param name="region">The region on the dynamic texture to write into</param>
        </member>
        <member name="M:Glaives.Core.Graphics.DynamicTexture.WriteColor(Glaives.Core.Graphics.Color)">
            <summary>
            <para>Write a single color into all pixels in the dynamic texture</para>
            </summary>
            <param name="color">The color to write</param>
        </member>
        <member name="M:Glaives.Core.Graphics.DynamicTexture.WriteDynamicTexture(Glaives.Core.Graphics.DynamicTexture,System.Int32,System.Int32)">
            <summary>
            <para>Write a dynamic texture into this dynamic texture</para>
            <para>The input dynamic texture must not be larger than the target dynamic texture</para>
            </summary>
            <param name="dynamicTexture">The dynamic texture to write into the target dynamic texture</param>
            <param name="x">The x start location on the target dynamic texture</param>
            <param name="y">The y start location on the target dynamic texture</param>
        </member>
        <member name="M:Glaives.Core.Graphics.DynamicTexture.WriteBytes(System.Byte[],Glaives.Core.IntRect)">
            <summary>
            <para>Write the RGBA bytes to the dynamic texture</para>
            </summary>
            <param name="bytes">The RGBA bytes to write</param>
            <param name="region">The region on the dynamic texture to write to</param>
        </member>
        <member name="M:Glaives.Core.Graphics.DynamicTexture.Save(System.String)">
            <summary>
            Save the dynamic texture to a file
            </summary>
            <param name="file">The path and file name + extension</param>
        </member>
        <member name="M:Glaives.Core.Graphics.DynamicTexture.Dispose">
            <inheritdoc />
            <summary>
            Dispose the dynamic texture
            </summary>
        </member>
        <member name="T:Glaives.Core.Graphics.Font">
            <inheritdoc cref="T:Glaives.Core.LoadableContent" />
            <summary>
            A font is used to draw text, it supports TTF (TrueTypeFont) and OTF (OpenTypeFont) files
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.Font.MaxFontSize">
            <summary>
            The maximum size allowed for fonts
            </summary>
        </member>
        <member name="F:Glaives.Core.Graphics.Font.FontSize">
            <summary>
            The size of the font
            </summary>
        </member>
        <member name="M:Glaives.Core.Graphics.Font.Dispose">
            <inheritdoc />
        </member>
        <member name="P:Glaives.Core.Graphics.Font.Default">
            <summary>
            Consolas regular 32
            </summary>
        </member>
        <member name="T:Glaives.Core.Graphics.FontCreateOptions">
            <inheritdoc />
            <summary>
            The create options to use for the font
            </summary>
        </member>
        <member name="F:Glaives.Core.Graphics.FontCreateOptions.FontSize">
            <summary>
            The size of the font
            </summary>
        </member>
        <member name="M:Glaives.Core.Graphics.FontCreateOptions.#ctor(System.Int32)">
            <summary>
            Create options for fonts
            </summary>
            <param name="fontSize">The size of the font</param>
        </member>
        <member name="M:Glaives.Core.Graphics.FontCreateOptions.IsEqualContent(Glaives.Core.ContentCreateOptions)">
            <inheritdoc />
        </member>
        <member name="M:Glaives.Core.Graphics.FontCreateOptions.ToString">
            <inheritdoc />
        </member>
        <member name="P:Glaives.Core.Graphics.GraphicsDevice.ScreenShader">
            <summary>
            <para>The screen shader is used to apply full-screen effects</para>
            <para>It is applied after all drawing is done</para>
            </summary>
        </member>
        <member name="M:Glaives.Core.Graphics.GraphicsDevice.DrawBatches">
            <inheritdoc />
        </member>
        <member name="P:Glaives.Core.Graphics.GraphicsDeviceBase.DrawCalls">
            <summary>
            <para>The amount of draw calls to the GPU needed to render the level</para>
            <para>Actors with the same Shader, Texture, BlendMode and DrawLayer will be batched together into the same draw call</para>
            </summary>
        </member>
        <member name="T:Glaives.Core.Graphics.Shader">
            <summary>
            <para>A shader is a set of GLSL scripts that run on the GPU</para>
            <para>Glaives uses special variable names to identify different "in" and "out" variables</para>
            <para>To create your own shaders, follow the instruction at: http://www.TODOPLACELINKHERE.net/Shaders </para>
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.Shader.Default">
            <summary>
            A simple textured vertex and fragment shader
            </summary>
        </member>
        <member name="M:Glaives.Core.Graphics.Shader.FromString(System.String,System.String)">
            <summary>
            Construct a new shader from memory directly
            </summary>
            <param name="vertexShaderString"></param>
            <param name="fragmentShaderString"></param>
            <returns></returns>
        </member>
        <member name="M:Glaives.Core.Graphics.Shader.#ctor(System.String,System.String)">
            <summary>
            <para>Create a new shader instance from files</para>
            <para>Actors with different shader instances will be drawn in different draw calls</para>
            <para>To reduce draw calls, use the same shader instance for multiple actors</para>
            </summary>
            <param name="vertexShaderFile"></param>
            <param name="fragmentShaderFile"></param>
        </member>
        <member name="M:Glaives.Core.Graphics.Shader.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Glaives.Core.Graphics.Shapes.MakeQuad">
            <summary>
            Create a vertex array that represents a quad
            </summary>
            <returns></returns>
        </member>
        <member name="T:Glaives.Core.Graphics.Sprite">
            <inheritdoc />
            The sprite drawable actor
        </member>
        <member name="P:Glaives.Core.Graphics.Sprite.SourceRect">
            <summary>
            The region on the texture to use to draw the sprite
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.Sprite.FlipX">
            <summary>
            Whether or not to flip the sprite horizontally
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.Sprite.FlipY">
            <summary>
            Whether or not to flip the sprite vertically
            </summary>
        </member>
        <member name="M:Glaives.Core.Graphics.Sprite.#ctor(Glaives.Core.Graphics.Texture)">
            <inheritdoc />
        </member>
        <member name="M:Glaives.Core.Graphics.Sprite.#ctor(Glaives.Core.Graphics.Texture,Glaives.Core.IntRect)">
            <inheritdoc />
        </member>
        <member name="P:Glaives.Core.Graphics.Sprite.LocalBounds">
            <inheritdoc />
        </member>
        <member name="M:Glaives.Core.Graphics.Sprite.FillVertexArray(Glaives.Core.Graphics.Vertex[]@)">
            <inheritdoc />
        </member>
        <member name="T:Glaives.Core.Graphics.Text">
            <inheritdoc />
            The text drawable actor generates quads that represents characters from a font
        </member>
        <member name="P:Glaives.Core.Graphics.Text.String">
            <summary>
            The string to be drawn by the text actor
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.Text.StyleFlags">
            <summary>
            The styling applied to the text (flags)
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.Text.Alignment">
            <summary>
            The <see cref="T:Glaives.Core.Graphics.TextAlignment"/> anchors the lines to the left, center or right side of the text bounds
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.Text.Font">
            <summary>
            The <see cref="P:Glaives.Core.Graphics.Text.Font"/> used to draw the text
            </summary>
        </member>
        <member name="T:Glaives.Core.Graphics.TextAlignment">
            <summary>
            The text alignment anchors the lines to the left, center or right side of the text bounds
            </summary>
        </member>
        <member name="F:Glaives.Core.Graphics.TextAlignment.Left">
            <summary>
            Align text left
            </summary>
        </member>
        <member name="F:Glaives.Core.Graphics.TextAlignment.Center">
            <summary>
            Align text center
            </summary>
        </member>
        <member name="F:Glaives.Core.Graphics.TextAlignment.Right">
            <summary>
            Align text right
            </summary>
        </member>
        <member name="T:Glaives.Core.Graphics.TextStyleFlags">
            <summary>
            <para>The italic flag skews the vertices to appear to be italic (if you use an italic font, don not include the italic flag)</para>
            <para>The underline flag adds a underline to text lines as a generated quad</para>
            <para>The strikeout flag adds a line through the text as a generated quad</para>
            <para>At the moment, boldness can not be done artificially, if you want bold text you should load a bold font</para>
            </summary>
        </member>
        <member name="F:Glaives.Core.Graphics.TextStyleFlags.Regular">
            <summary>
            No modifications are done to the text
            </summary>
        </member>
        <member name="F:Glaives.Core.Graphics.TextStyleFlags.Italic">
            <summary>
            Skews the vertices to appear to be italic (if you use an italic font, don not include the italic flag)
            </summary>
        </member>
        <member name="F:Glaives.Core.Graphics.TextStyleFlags.Underline">
            <summary>
            Adds a underline to text lines as a generated quad
            </summary>
        </member>
        <member name="F:Glaives.Core.Graphics.TextStyleFlags.Strikeout">
            <summary>
            Adds a line through the text as a generated quad
            </summary>
        </member>
        <member name="T:Glaives.Core.Graphics.Texture">
            <inheritdoc cref="T:Glaives.Core.LoadableContent" />
            <summary>
            <para>A texture exists only on the GPU and is therefor not as flexible as a dynamic texture</para>
            <para>Use a dynamic texture if you want access and/or modify the pixel data on the CPU</para>
            <para>A dynamic texture can be converted to a texture and vise-versa (do not forget to dispose the dynamic texture when you are done with it)</para>
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.Texture.MaxTextureSize">
            <summary>
            The maximum width/height that a texture supports
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.Texture.Handle">
            <summary>
            The gl handle 
            </summary>
        </member>
        <member name="F:Glaives.Core.Graphics.Texture.Size">
            <summary>
            The dimensions of the texture
            </summary>
        </member>
        <member name="M:Glaives.Core.Graphics.Texture.#ctor(System.Int32,System.Int32,Glaives.Core.Graphics.Color,Glaives.Core.Graphics.TextureCreateOptions)">
            <summary>
            Create a new empty texture 
            </summary>
            <param name="width">The width of the texture</param>
            <param name="height">The height of the texture</param>
            <param name="color">The color for all pixels in the texture</param>
            <param name="createOptions">The create options</param>
        </member>
        <member name="M:Glaives.Core.Graphics.Texture.#ctor(System.Int32,System.Int32,System.Byte[],Glaives.Core.Graphics.TextureCreateOptions)">
            <summary>
            Create a new texture
            </summary>
            <param name="width">The width of the texture</param>
            <param name="height">The height of the texture</param>
            <param name="bytes">The RGBA bytes to load this texture with</param>
            <param name="createOptions">The create options</param>
        </member>
        <member name="M:Glaives.Core.Graphics.Texture.#ctor(Glaives.Core.Graphics.DynamicTexture,Glaives.Core.Graphics.TextureCreateOptions)">
            <summary>
            Create a new texture
            </summary>
            <param name="dynamicTexture">The dynamic texture to copy the pixel data from</param>
            <param name="createOptions">The create options</param>
        </member>
        <member name="M:Glaives.Core.Graphics.Texture.Update(System.Collections.Generic.IEnumerable{Glaives.Core.Graphics.Color},Glaives.Core.IntRect)">
            <summary>
            Update the texture on the GPU using 32-bit RGBA colors
            </summary>
            <param name="colors">The color pixels to be submitted to the texture</param>
            <param name="region">The region of the sub texture</param>
        </member>
        <member name="M:Glaives.Core.Graphics.Texture.Update(Glaives.Core.Graphics.Color)">
            <summary>
            Update all the pixels in the texture on the GPU to a single 32-bit RGBA color
            </summary>
            <param name="color">The color for all the pixels in the texture</param>
        </member>
        <member name="M:Glaives.Core.Graphics.Texture.Update(System.Byte[],Glaives.Core.IntRect)">
            <summary>
            Update the texture on the GPU
            </summary>
            <param name="bytes">The bytes to be submitted to the texture</param>
            <param name="region">The region of the sub texture</param>
        </member>
        <member name="M:Glaives.Core.Graphics.Texture.GetBytes">
            <summary>
            Get the RGBA bytes of the texture from the GPU
            </summary>
        </member>
        <member name="M:Glaives.Core.Graphics.Texture.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Glaives.Core.Graphics.TextureCreateOptions">
            <inheritdoc />
            <summary>
            The create options to use for the texture
            </summary>
        </member>
        <member name="F:Glaives.Core.Graphics.TextureCreateOptions.FilterMode">
            <summary>
            The way the texture is filtered
            </summary>
        </member>
        <member name="F:Glaives.Core.Graphics.TextureCreateOptions.WrapMode">
            <summary>
            The way the texture is wrapped outside of the texture coordinates
            </summary>
        </member>
        <member name="M:Glaives.Core.Graphics.TextureCreateOptions.#ctor(Glaives.Core.Graphics.TextureFilterMode,Glaives.Core.Graphics.TextureWrapMode)">
            <summary>
            Create new texture create options
            </summary>
            <param name="filterMode">The way the texture is filtered</param>
            <param name="wrapMode">The way the texture is wrapped outside of the texture coordinates</param>
        </member>
        <member name="M:Glaives.Core.Graphics.TextureCreateOptions.IsEqualContent(Glaives.Core.ContentCreateOptions)">
            <inheritdoc />
        </member>
        <member name="M:Glaives.Core.Graphics.TextureCreateOptions.ToString">
            <inheritdoc />
        </member>
        <member name="P:Glaives.Core.Graphics.TextureCreateOptions.Smooth">
            <summary>
            <para>FilterMode : Smooth</para>
            <para>WrapMode : ClampToEdge</para>
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.TextureCreateOptions.Sharp">
            <summary>
            <para>FilterMode : Sharp</para>
            <para>WrapMode : ClampToEdge</para>
            </summary>
        </member>
        <member name="T:Glaives.Core.Graphics.TextureFilterMode">
            <summary>
            The way the texture is filtered
            </summary>
        </member>
        <member name="F:Glaives.Core.Graphics.TextureFilterMode.Smooth">
            <summary>
            For smoother textures
            </summary>
        </member>
        <member name="F:Glaives.Core.Graphics.TextureFilterMode.Sharp">
            <summary>
            For pixel-perfect textures
            </summary>
        </member>
        <member name="T:Glaives.Core.Graphics.TextureWrapMode">
            <summary>
            The way the texture is sampled outside the coordinate range of 0 to 1
            </summary>
        </member>
        <member name="F:Glaives.Core.Graphics.TextureWrapMode.Repeat">
            <summary>
            The integer part of the coordinate is ignored and a repeated pattern is formed
            </summary>
        </member>
        <member name="F:Glaives.Core.Graphics.TextureWrapMode.MirroredRepeat">
            <summary>
            Same as Repeat but it will be mirrored when the integer part of the coordinate is odd
            </summary>
        </member>
        <member name="F:Glaives.Core.Graphics.TextureWrapMode.ClampToEdge">
            <summary>
            The coordinate will be clamped between 0 and 1
            </summary>
        </member>
        <member name="F:Glaives.Core.Graphics.TextureWrapMode.ClampToBorder">
            <summary>
            The coordinates that fall outside the range will be given a border
            </summary>
        </member>
        <member name="T:Glaives.Core.Graphics.View">
            <inheritdoc />
            <summary>
            <para>A view is used to project the geometry onto the viewport</para>
            <para>It contains the projection matrix which is used in the vertex shaders to transform the vertices to view-space</para>
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.View.ProjectionMatrix">
            <summary>
            The projection matrix of the current view is passed to the vertex shaders to transform the vertices to view-space
            </summary>
        </member>
        <member name="P:Glaives.Core.Graphics.View.Center">
            <summary>
            The center of the view
            </summary>
        </member>
        <member name="T:Glaives.Core.Input.InputActionBinding">
            <summary>
            Binding an id to an array of keys
            </summary>
        </member>
        <member name="P:Glaives.Core.Input.InputActionBinding.Id">
            <summary>
            The identifier for this input binding
            </summary>
        </member>
        <member name="P:Glaives.Core.Input.InputActionBinding.Keys">
            <summary>
            The keys associated with this input binding
            </summary>
        </member>
        <member name="T:Glaives.Core.Input.InputAxisScalePair">
            <summary>
            An axis and a scale for the value of that axis
            </summary>
        </member>
        <member name="P:Glaives.Core.Input.InputAxisScalePair.Axis">
            <summary>
            The axis
            </summary>
        </member>
        <member name="P:Glaives.Core.Input.InputAxisScalePair.Scale">
            <summary>
            The value by which to multiply the axis value
            </summary>
        </member>
        <member name="T:Glaives.Core.Input.InputAxisBinding">
            <summary>
            Binding an id to an axis
            </summary>
        </member>
        <member name="P:Glaives.Core.Input.InputAxisBinding.Id">
            <summary>
            The identifier for this input axis binding
            </summary>
        </member>
        <member name="P:Glaives.Core.Input.InputAxisBinding.AxisScalePairs">
            <summary>
            The pairs contain the axes and the scales by which to multiply their values
            </summary>
        </member>
        <member name="M:Glaives.Core.Input.InputBinder.BindAction(System.String,Glaives.Core.Input.InputBinder.InputActionEvent)">
            <summary>
            Bind an input action to a function that handles the input event
            </summary>
            <param name="inputActionId">The id of the input action binding</param>
            <param name="eventHandler">The function that will handle this input action event</param>
        </member>
        <member name="M:Glaives.Core.Input.InputBinder.BindAxis(System.String,Glaives.Core.Input.InputBinder.InputAxisEvent)">
            <summary>
            Bind an input axis to a function that handles the input event
            </summary>
            <param name="inputAxisId">The id of the input axis binding</param>
            <param name="eventHandler">The function that will handle this input axis event</param>
        </member>
        <member name="M:Glaives.Core.Input.InputBinder.UnbindAction(System.String)">
            <summary>
            Unbind a specific action (does nothing if the action is not bound)
            </summary>
            <param name="inputActionId"></param>
        </member>
        <member name="M:Glaives.Core.Input.InputBinder.UnbindAxis(System.String)">
            <summary>
            Unbind a specific axis (does nothing if the axis is not bound)
            </summary>
            <param name="inputAxisId"></param>
        </member>
        <member name="M:Glaives.Core.Input.InputBinder.UnbindAllActions">
            <summary>
            Unbind all actions
            </summary>
        </member>
        <member name="M:Glaives.Core.Input.InputBinder.UnbindAllAxes">
            <summary>
            Unbind all axes
            </summary>
        </member>
        <member name="M:Glaives.Core.Input.InputBinder.UnbindAll">
            <summary>
            Unbind all actions and axes
            </summary>
        </member>
        <member name="F:Glaives.Core.Input.Key.GamepadRightThumbstick">
            <summary>
            The "press" of the thumbstick
            </summary>
        </member>
        <member name="F:Glaives.Core.Input.Key.GamepadLeftThumbstick">
            <summary>
            The "press" of the thumbstick
            </summary>
        </member>
        <member name="F:Glaives.Core.Input.Key.GamepadRightThumbstickX">
            <summary>
            Triggered when the thumbstick's X-axis reaches a threshold
            </summary>
        </member>
        <member name="F:Glaives.Core.Input.Key.GamepadRightThumbstickY">
            <summary>
            Triggered when the thumbstick's Y-axis reaches a threshold
            </summary>
        </member>
        <member name="F:Glaives.Core.Input.Key.GamepadLeftThumbstickX">
            <summary>
            Triggered when the thumbstick's X-axis reaches a threshold
            </summary>
        </member>
        <member name="F:Glaives.Core.Input.Key.GamepadLeftThumbstickY">
            <summary>
            Triggered when the thumbstick's Y-axis reaches a threshold
            </summary>
        </member>
        <member name="F:Glaives.Core.Input.Key.GamepadRightTrigger">
            <summary>
            Triggered when the trigger axis has reached a threshold
            </summary>
        </member>
        <member name="F:Glaives.Core.Input.Key.GamepadLeftTrigger">
            <summary>
            Triggered when the trigger axis has reached a threshold
            </summary>
        </member>
        <member name="M:Glaives.Core.Internal.Content.ContentInfo.GetHashCode">
            <inheritdoc />
        </member>
        <member name="P:Glaives.Core.Internal.Graphics.GeometryBatch.VertexArrayPosition">
            <summary>
            Is the same as the amount of vertices to be drawn by this batch
            </summary>
        </member>
        <member name="M:Glaives.Core.Internal.Graphics.GlyphInfo.Equals(Glaives.Core.Internal.Graphics.GlyphInfo)">
            <inheritdoc />
        </member>
        <member name="M:Glaives.Core.Internal.Graphics.GlyphInfo.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Glaives.Core.Internal.Graphics.GlyphInfo.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:Glaives.Core.Internal.Graphics.ImGuiHelper">
            <summary>
            Static utility functions for ImGui 
            </summary>
        </member>
        <member name="T:Glaives.Core.Internal.LevelManagment.LevelManager">
            <summary>
            Manages loading and unloading of levels
            </summary>
        </member>
        <member name="P:Glaives.Core.Internal.LevelManagment.LevelManager.Level">
            <summary>
            The level currently loaded 
            </summary>
        </member>
        <member name="M:Glaives.Core.Internal.LevelManagment.LevelManager.LoadLevel``1">
            <summary>
            Unload the current level and load the new level
            </summary>
            <typeparam name="T">The type of the level to load</typeparam>
        </member>
        <member name="M:Glaives.Core.Internal.LevelManagment.LevelManager.LoadLevel(System.Type)">
            <summary>
            Unload the current level and load the new level
            </summary>
            <param name="levelType">The type of the level to load</param>
        </member>
        <member name="P:Glaives.Core.IntVector2.Zero">
            <summary>
            An int vector with X and Y set to 0
            </summary>
        </member>
        <member name="P:Glaives.Core.IntVector2.UnitX">
            <summary>
            An int vector with X set to 1 and Y set to 0
            </summary>
        </member>
        <member name="P:Glaives.Core.IntVector2.UnitY">
            <summary>
            An int vector with X set to 0 and Y set to 1
            </summary>
        </member>
        <member name="P:Glaives.Core.IntVector2.Unit">
            <summary>
            An int vector with X and Y set to 1
            </summary>
        </member>
        <member name="T:Glaives.Core.Level">
            <summary>
            A hierarchy of GameObjects
            </summary>
        </member>
        <member name="P:Glaives.Core.Level.Engine">
            <summary>
            A shorthand to Engine.Get
            </summary>
        </member>
        <member name="P:Glaives.Core.Level.Root">
            <summary>
            The root actor of the level is immutable and will always exist in the level
            </summary>
        </member>
        <member name="P:Glaives.Core.Level.ActorCount">
            <summary>
            The total amount of actors in the level (not including the level root)
            </summary>
        </member>
        <member name="P:Glaives.Core.Level.DefaultView">
            <summary>
            The default view 
            </summary>
        </member>
        <member name="P:Glaives.Core.Level.CurrentView">
            <summary>
            The currently active view
            </summary>
        </member>
        <member name="P:Glaives.Core.Level.CoroutineRunner">
            <summary>
            The coroutine runner associated with this level
            </summary>
        </member>
        <member name="F:Glaives.Core.Level.PendingDestroyActors">
            <summary>
            Actors to be destroyed at the end of the frame
            </summary>
        </member>
        <member name="M:Glaives.Core.Level.BuildHierarchyString">
            <summary>
            A string that represents the level hierarchy
            </summary>
            <returns></returns>
        </member>
        <member name="M:Glaives.Core.Level.LoadLevel">
            <summary>
            Load your level content here
            </summary>
        </member>
        <member name="M:Glaives.Core.Level.Tick(System.Single)">
            <summary>
            Called every tick 
            </summary>
            <param name="deltaTime">The elapsed time in seconds since the last tick</param>
        </member>
        <member name="M:Glaives.Core.Level.OnImGui">
            <summary>
            Per level ImGui rendering. for global gui, override game instance OnImGui
            </summary>
        </member>
        <member name="M:Glaives.Core.LoadableContent.Dispose">
            <inheritdoc />
        </member>
        <member name="T:Glaives.Core.UniqueString">
            <summary>
            Ensures there is no other UniqueString with the same string value during the same runtime
            Adds a postfix to make the string unique to other UniqueStrings
            </summary>
        </member>
        <member name="F:Glaives.Core.UniqueString.String">
            <summary>
            The unique string
            </summary>
        </member>
        <member name="M:Glaives.Core.UniqueString.#ctor(System.String)">
            <summary>
            Potentially modifies the input str by adding a postfix to ensure it is unique to other UniqueStrings
            </summary>
            <param name="str"></param>
        </member>
        <member name="M:Glaives.Core.Utils.IOUtils.EnumerateFilesInDirectoryResursively(System.String)">
            <summary>
            Get a list of file paths for each file in the directory and all it's sub-directories recursively
            </summary>
            <param name="directory">The root directory</param>
        </member>
        <member name="T:Glaives.Core.Utils.MathEx">
            <summary>
            Additional math utility methods to extend System.Math
            </summary>
        </member>
        <member name="M:Glaives.Core.Utils.MathEx.FastSin(System.Single)">
            <summary>
            Fast sine using a precomputed lookup table
            </summary>
            <param name="radians"></param>
            <returns></returns>
        </member>
        <member name="M:Glaives.Core.Utils.MathEx.FastCos(System.Single)">
            <summary>
            Fast cosine using a precomputed lookup table
            </summary>
            <param name="radians"></param>
            <returns></returns>
        </member>
        <member name="P:Glaives.Core.Vector2.Length">
            <summary>
            The length of the vector
            </summary>
        </member>
        <member name="P:Glaives.Core.Vector2.LengthSquared">
            <summary>
            The square length of the vector (offers better performance than Length)
            </summary>
        </member>
        <member name="M:Glaives.Core.Vector2.Dot(Glaives.Core.Vector2,Glaives.Core.Vector2)">
            <summary>
            Calculate the dot product of 2 vectors
            </summary>
            <param name="left">Input vector a</param>
            <param name="right">Input vector b</param>
            <returns>The dot product</returns>
        </member>
        <member name="M:Glaives.Core.Vector2.Lerp(Glaives.Core.Vector2,Glaives.Core.Vector2,System.Single)">
            <summary>
            Calculate the linearly interpolated vector
            </summary>
            <param name="a">Input vector a</param>
            <param name="b">Input vector b</param>
            <param name="alpha">The amount of interpolation</param>
            <returns>The interpolated vector</returns>
        </member>
        <member name="M:Glaives.Core.Vector2.Normalize(Glaives.Core.Vector2)">
            <summary>
            Scale the vector to unit length
            </summary>
            <param name="vector">The input vector</param>
            <returns>The normalized vector</returns>
        </member>
        <member name="P:Glaives.Core.Vector2.Unit">
            <summary>
            A vector2 with X and Y set to 1
            </summary>
        </member>
        <member name="P:Glaives.Core.Vector2.UnitX">
            <summary>
            A vector2 with X set to 1 and Y set to 0
            </summary>
        </member>
        <member name="P:Glaives.Core.Vector2.UnitY">
            <summary>
            A vector2 with X set to 0 and Y set to 1
            </summary>
        </member>
        <member name="P:Glaives.Core.Vector2.Zero">
            <summary>
            A vector2 with X and Y set to 0
            </summary>
        </member>
        <member name="T:ImGuiNET.ColorEditFlags">
            <summary>
            Enumeration for ColorEdit3() / ColorEdit4() / ColorPicker3() / ColorPicker4() / ColorButton()
            </summary>
        </member>
        <member name="T:ImGuiNET.ColorTarget">
            <summary>
            Enumeration for PushStyleColor() / PopStyleColor()
            </summary>
        </member>
        <member name="F:ImGuiNET.ColorTarget.FrameBg">
            <summary>
            Background of checkbox, radio button, plot, slider, text input
            </summary>
        </member>
        <member name="F:ImGuiNET.ColorTarget.ModalWindowDarkening">
            <summary>
            darken entire screen when a modal window is active
            </summary>
        </member>
        <member name="F:ImGuiNET.ComboFlags.PopupAlignLeft">
            <summary>
            Align the popup toward the left by default
            </summary>
        </member>
        <member name="F:ImGuiNET.ComboFlags.HeightSmall">
            <summary>
            Max ~4 items visible. Tip: If you want your combo popup to be a specific size you can use SetNextWindowSizeConstraints() prior to calling BeginCombo()
            </summary>
        </member>
        <member name="F:ImGuiNET.ComboFlags.HeightRegular">
            <summary>
            Max ~8 items visible (default)
            </summary>
        </member>
        <member name="F:ImGuiNET.ComboFlags.HeightLarge">
            <summary>
            Max ~20 items visible
            </summary>
        </member>
        <member name="F:ImGuiNET.ComboFlags.HeightLargest">
            <summary>
            As many fitting items as possible
            </summary>
        </member>
        <member name="T:ImGuiNET.Condition">
            <summary>
            Condition flags for ImGui::SetWindow***(), SetNextWindow***(), SetNextTreeNode***() functions.
            All those functions treat 0 as a shortcut to Always.
            </summary>
        </member>
        <member name="F:ImGuiNET.Condition.Always">
            <summary>
            Set the variable.
            </summary>
        </member>
        <member name="F:ImGuiNET.Condition.Once">
            <summary>
            Only set the variable on the first call per runtime session
            </summary>
        </member>
        <member name="F:ImGuiNET.Condition.FirstUseEver">
            <summary>
            Only set the variable if the window doesn't exist in the .ini file
            </summary>
        </member>
        <member name="F:ImGuiNET.Condition.Appearing">
            <summary>
            Only set the variable if the window is appearing after being inactive (or the first time)
            </summary>
        </member>
        <member name="F:ImGuiNET.DragDropFlags.SourceNoPreviewTooltip">
            <summary>
            By default, a successful call to BeginDragDropSource opens a tooltip so you can display a preview or description of the source contents. This flag disable this behavior.
            </summary>
        </member>
        <member name="F:ImGuiNET.DragDropFlags.SourceNoDisableHover">
            <summary>
            By default, when dragging we clear data so that IsItemHovered() will return true, to avoid subsequent user code submitting tooltips. This flag disable this behavior so you can still call IsItemHovered() on the source item.
            </summary>
        </member>
        <member name="F:ImGuiNET.DragDropFlags.SourceNoHoldToOpenOthers">
            <summary>
            Disable the behavior that allows to open tree nodes and collapsing header by holding over them while dragging a source item.
            </summary>
        </member>
        <member name="F:ImGuiNET.DragDropFlags.SourceAllowNullID">
            <summary>
            Allow items such as Text(), Image() that have no unique identifier to be used as drag source, by manufacturing a temporary identifier based on their window-relative position. This is extremely unusual within the dear imgui ecosystem and so we made it explicit.
            </summary>
        </member>
        <member name="F:ImGuiNET.DragDropFlags.SourceExtern">
            <summary>
            External source (from outside of imgui), won't attempt to read current item/window info. Will always return true. Only one Extern source can be active simultaneously.
            </summary>
        </member>
        <member name="F:ImGuiNET.DragDropFlags.AcceptBeforeDelivery">
            <summary>
            AcceptDragDropPayload() will returns true even before the mouse button is released. You can then call IsDelivery() to test if the payload needs to be delivered.
            </summary>
        </member>
        <member name="F:ImGuiNET.DragDropFlags.AcceptNoDrawDefaultRect">
            <summary>
            Do not draw the default highlight rectangle when hovering over target.
            </summary>
        </member>
        <member name="F:ImGuiNET.DragDropFlags.AcceptPeekOnly">
            <summary>
            For peeking ahead and inspecting the payload before delivery.
            </summary>
        </member>
        <member name="T:ImGuiNET.DrawCmd">
            <summary>
            Typically, 1 command = 1 gpu draw call (unless command is a callback)
            </summary>
        </member>
        <member name="F:ImGuiNET.DrawCmd.ElemCount">
            <summary>
            Number of indices (multiple of 3) to be rendered as triangles.
            Vertices are stored in the callee ImDrawList's vtx_buffer[] array, indices in idx_buffer[].
            </summary>
        </member>
        <member name="F:ImGuiNET.DrawCmd.ClipRect">
            <summary>
            Clipping rectangle (x1, y1, x2, y2)
            </summary>
        </member>
        <member name="F:ImGuiNET.DrawCmd.TextureId">
            <summary>
            User-provided texture ID. Set by user in ImfontAtlas::SetTexID() for fonts or passed to Image*() functions.
            Ignore if never using images or multiple fonts atlas.
            </summary>
        </member>
        <member name="F:ImGuiNET.DrawCmd.UserCallback">
            <summary>
            If != NULL, call the function instead of rendering the vertices. clip_rect and texture_id will be set normally.
            </summary>
        </member>
        <member name="F:ImGuiNET.DrawCmd.UserCallbackData">
            <summary>
            The draw callback code can access this.
            </summary>
        </member>
        <member name="T:ImGuiNET.DrawData">
            <summary>
            All draw data to render an ImGui frame
            </summary>
        </member>
        <member name="F:ImGuiNET.DrawData.Valid">
            <summary>
            Only valid after Render() is called and before the next NewFrame() is called.
            </summary>
        </member>
        <member name="F:ImGuiNET.DrawData.TotalVtxCount">
            <summary>
            For convenience, sum of all cmd_lists vtx_buffer.Size
            </summary>
        </member>
        <member name="F:ImGuiNET.DrawData.TotalIdxCount">
            <summary>
            For convenience, sum of all cmd_lists idx_buffer.Size
            </summary>
        </member>
        <member name="T:ImGuiNET.NativeDrawList">
            <summary>
            Draw command list
            This is the low-level list of polygons that ImGui functions are filling. At the end of the frame, all command lists are passed to your ImGuiIO::RenderDrawListFn function for rendering.
            At the moment, each ImGui window contains its own ImDrawList but they could potentially be merged in the future.
            If you want to add custom rendering within a window, you can use ImGui::GetWindowDrawList() to access the current draw list and add your own primitives.
            You can interleave normal ImGui:: calls and adding primitives to the current draw list.
            All positions are in screen coordinates (0,0=top-left, 1 pixel per unit). Primitives are always added to the list and not culled (culling is done at render time and at a higher-level by ImGui:: functions).
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeDrawList.CmdBuffer">
            <summary>
            ImVector(ImDrawCmd).
            Commands. Typically 1 command = 1 gpu draw call.
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeDrawList.IdxBuffer">
            <summary>
            ImVector(ImDrawIdx).
            Index buffer. Each command consume ImDrawCmd::ElemCount of those
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeDrawList.VtxBuffer">
            <summary>
            ImVector(ImDrawVert)
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeDrawList._OwnerName">
            <summary>
            Pointer to owner window's name (if any) for debugging
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeDrawList._VtxCurrentIdx">
            <summary>
            [Internal] == VtxBuffer.Size
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeDrawList._VtxWritePtr">
            <summary>
            [Internal] point within VtxBuffer.Data after each add command (to avoid using the ImVector operators too much)
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeDrawList._IdxWritePtr">
            <summary>
            [Internal] point within IdxBuffer.Data after each add command (to avoid using the ImVector operators too much)
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeDrawList._ClipRectStack">
            <summary>
            [Internal]
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeDrawList._TextureIdStack">
            <summary>
            [Internal]
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeDrawList._Path">
            <summary>
            [Internal] current path building
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeDrawList._ChannelsCurrent">
            <summary>
            [Internal] current channel number (0)
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeDrawList._ChannelsCount">
            <summary>
            [Internal] number of active channels (1+)
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeDrawList._Channels">
            <summary>
            [Internal] draw channels for columns API (not resized down so _ChannelsCount may be smaller than _Channels.Size)
            </summary>
        </member>
        <member name="T:ImGuiNET.NativeFont">
            <summary>
            Font runtime data and rendering.
            ImFontAtlas automatically loads a default embedded font for you when you call GetTexDataAsAlpha8() or GetTexDataAsRGBA32().
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeFont.FontSize">
            <summary>
            Height of characters, set during loading (don't change after loading).
            Default value: [user-set]
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeFont.Scale">
            <summary>
            Base font scale, multiplied by the per-window font scale which you can adjust with SetFontScale()
            Default value: 1.0f.
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeFont.DisplayOffset">
            <summary>
            Offset font rendering by xx pixels.
            Default value: (0.0f, 1.0f)
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeFont.Glyphs">
            <summary>
            ImVector(Glyph)
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeFont.IndexXAdvance">
            <summary>
            Sparse. Glyphs->XAdvance directly indexable (more cache-friendly that reading from Glyphs,
            for CalcTextSize functions which are often bottleneck in large UI).
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeFont.IndexLookup">
            <summary>
            Sparse. Index glyphs by Unicode code-point.
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeFont.FallbackGlyph">
            <summary>
            Equivalent to FindGlyph(FontFallbackChar)
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeFont.FallbackChar">
            <summary>
            Replacement glyph if one isn't found. Only set via SetFallbackChar()
            Default value: '?'
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeFont.ConfigData">
            <summary>
            ImFontConfig*. Pointer within ImFontAtlas->ConfigData
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeFont.ContainerAtlas">
            <summary>
            ImFontAtlas*
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeFont.Ascent">
            <summary>
            Ascent: distance from top to bottom of e.g. 'A' [0..FontSize]
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeFont.Descent">
            <summary>
            Ascent: distance from top to bottom of e.g. 'A' [0..FontSize]
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeFontAtlas.TexID">
            <summary>
            User data to refer to the texture once it has been uploaded to user's graphic systems.
            It ia passed back to you during rendering.
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeFontAtlas.TexPixelsAlpha8">
            <summary>
            1 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeFontAtlas.TexPixelsRGBA32">
            <summary>
            4 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight * 4
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeFontAtlas.TexWidth">
            <summary>
            Texture width calculated during Build().
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeFontAtlas.TexHeight">
            <summary>
            Texture height calculated during Build().
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeFontAtlas.TexDesiredWidth">
            <summary>
            Texture width desired by user before Build(). Must be a power-of-two.
            If have many glyphs your graphics API have texture size restrictions you may want to increase texture width to decrease height.
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeFontAtlas.TexUvWhitePixel">
            <summary>
            Texture coordinates to a white pixel (part of the TexExtraData block)
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeFontAtlas.Fonts">
            <summary>
            (ImVector(ImFont*)
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeFontAtlas.ConfigData">
            <summary>
            ImVector(ImFontConfig). Internal data
            </summary>
        </member>
        <member name="F:ImGuiNET.FontConfig.FontData">
            <summary>
            TTF data
            </summary>
        </member>
        <member name="F:ImGuiNET.FontConfig.FontDataSize">
            <summary>
            TTF data size
            </summary>
        </member>
        <member name="F:ImGuiNET.FontConfig.FontDataOwnedByAtlas">
            <summary>
            TTF data ownership taken by the container ImFontAtlas (will delete memory itself).
            Set to true.
            </summary>
        </member>
        <member name="F:ImGuiNET.FontConfig.FontNo">
            <summary>
            0.
            Index of font within TTF file
            </summary>
        </member>
        <member name="F:ImGuiNET.FontConfig.SizePixels">
            <summary>
            Size in pixels for rasterizer.
            </summary>
        </member>
        <member name="F:ImGuiNET.FontConfig.OversampleH">
            <summary>
            Rasterize at higher quality for sub-pixel positioning. We don't use sub-pixel positions on the Y axis.
            Set to 3.
            </summary>
        </member>
        <member name="F:ImGuiNET.FontConfig.OversampleV">
            <summary>
            Rasterize at higher quality for sub-pixel positioning. We don't use sub-pixel positions on the Y axis.
            Set to 1.
            </summary>
        </member>
        <member name="F:ImGuiNET.FontConfig.PixelSnapH">
            <summary>
            Align every character to pixel boundary (if enabled, set OversampleH/V to 1).
            Set to false.
            </summary>
        </member>
        <member name="F:ImGuiNET.FontConfig.GlyphExtraSpacing">
            <summary>
            Extra spacing (in pixels) between glyphs.
            Set to (0, 0).
            </summary>
        </member>
        <member name="F:ImGuiNET.FontConfig.GlyphOffset">
            <summary>
            Offset all glyphs from this font input.
            Set to (0, 0).
            </summary>
        </member>
        <member name="F:ImGuiNET.FontConfig.GlyphRanges">
            <summary>
            List of Unicode range (2 value per range, values are inclusive, zero-terminated list).
            </summary>
        </member>
        <member name="F:ImGuiNET.FontConfig.MergeMode">
            <summary>
            Merge into previous ImFont, so you can combine multiple inputs font into one ImFont (e.g. ASCII font + icons + Japanese glyphs).
            Set to false.
            </summary>
        </member>
        <member name="F:ImGuiNET.FontConfig.RasterizerFlags">
            <summary>
            Settings for custom font rasterizer (e.g. ImGuiFreeType). Leave as zero if you aren't using one.
            Defaults to 0.
            </summary>
        </member>
        <member name="F:ImGuiNET.FontConfig.RasterizerMultiply">
            <summary>
            Brighten (&gt;1.0f) or darken (&lt;1.0f) font output. Brightening small fonts may be a good workaround to make them more readable.
            Defaults to 1.0.
            </summary>
        </member>
        <member name="F:ImGuiNET.FontConfig.Name">
            <summary>
            [Internal Use Only] Name (strictly for debugging)
            </summary>
        </member>
        <member name="F:ImGuiNET.FontConfig.DstFont">
            <summary>
            [Internal Use Only]
            </summary>
        </member>
        <member name="T:ImGuiNET.GuiKey">
            <summary>
            User fill ImGuiIO.KeyMap[] array with indices into the ImGuiIO.KeysDown[512] array
            </summary>
        </member>
        <member name="F:ImGuiNET.GuiKey.Tab">
            <summary>
            for tabbing through fields
            </summary>
        </member>
        <member name="F:ImGuiNET.GuiKey.LeftArrow">
            <summary>
            for text edit
            </summary>
        </member>
        <member name="F:ImGuiNET.GuiKey.RightArrow">
            <summary>
            for text edit
            </summary>
        </member>
        <member name="F:ImGuiNET.GuiKey.UpArrow">
            <summary>
            for text edit
            </summary>
        </member>
        <member name="F:ImGuiNET.GuiKey.DownArrow">
            <summary>
            for text edit
            </summary>
        </member>
        <member name="F:ImGuiNET.GuiKey.Home">
            <summary>
            for text edit
            </summary>
        </member>
        <member name="F:ImGuiNET.GuiKey.End">
            <summary>
            for text edit
            </summary>
        </member>
        <member name="F:ImGuiNET.GuiKey.Delete">
            <summary>
            for text edit
            </summary>
        </member>
        <member name="F:ImGuiNET.GuiKey.Backspace">
            <summary>
            for text edit
            </summary>
        </member>
        <member name="F:ImGuiNET.GuiKey.Enter">
            <summary>
            for text edit
            </summary>
        </member>
        <member name="F:ImGuiNET.GuiKey.Escape">
            <summary>
            for text edit
            </summary>
        </member>
        <member name="F:ImGuiNET.GuiKey.A">
            <summary>
            for text edit CTRL+A: select all
            </summary>
        </member>
        <member name="F:ImGuiNET.GuiKey.C">
            <summary>
            for text edit CTRL+C: copy
            </summary>
        </member>
        <member name="F:ImGuiNET.GuiKey.V">
            <summary>
            for text edit CTRL+V: paste
            </summary>
        </member>
        <member name="F:ImGuiNET.GuiKey.X">
            <summary>
            for text edit CTRL+X: cut
            </summary>
        </member>
        <member name="F:ImGuiNET.GuiKey.Y">
            <summary>
            for text edit CTRL+Y: redo
            </summary>
        </member>
        <member name="F:ImGuiNET.GuiKey.Z">
            <summary>
            for text edit CTRL+Z: undo
            </summary>
        </member>
        <member name="M:ImGuiNET.ImGui.ScaleClipRects(ImGuiNET.DrawData*,Glaives.Core.Vector2)">
            <summary>
            Helper to scale the ClipRect field of each ImDrawCmd.
            Use if your final output buffer is at a different scale than ImGui expects,
            or if there is a difference between your window resolution and framebuffer resolution.
            </summary>
            <param name="drawData">Pointer to the DrawData to scale.</param>
            <param name="scale">The scale to apply.</param>
        </member>
        <member name="T:ImGuiNET.ImGuiNative">
            <summary>
            Contains all of the exported functions from the native (c)imGui module.
            </summary>
        </member>
        <member name="F:ImGuiNET.ImVector.Data">
            <summary>T* Data</summary>
        </member>
        <member name="T:ImGuiNET.InputTextFlags">
            <summary>
            Flags for ImGui.InputText()
            </summary>
        </member>
        <member name="F:ImGuiNET.InputTextFlags.CharsDecimal">
            <summary>
            Allow 0123456789.+-*/
            </summary>
        </member>
        <member name="F:ImGuiNET.InputTextFlags.CharsHexadecimal">
            <summary>
            Allow 0123456789ABCDEFabcdef
            </summary>
        </member>
        <member name="F:ImGuiNET.InputTextFlags.CharsUppercase">
            <summary>
            Turn a..z into A..Z
            </summary>
        </member>
        <member name="F:ImGuiNET.InputTextFlags.CharsNoBlank">
            <summary>
            Filter out spaces, tabs
            </summary>
        </member>
        <member name="F:ImGuiNET.InputTextFlags.AutoSelectAll">
            <summary>
            Select entire text when first taking mouse focus
            </summary>
        </member>
        <member name="F:ImGuiNET.InputTextFlags.EnterReturnsTrue">
            <summary>
            Return 'true' when Enter is pressed (as opposed to when the value was modified)
            </summary>
        </member>
        <member name="F:ImGuiNET.InputTextFlags.CallbackCompletion">
            <summary>
            Call user function on pressing TAB (for completion handling)
            </summary>
        </member>
        <member name="F:ImGuiNET.InputTextFlags.CallbackHistory">
            <summary>
            Call user function on pressing Up/Down arrows (for history handling)
            </summary>
        </member>
        <member name="F:ImGuiNET.InputTextFlags.CallbackAlways">
            <summary>
            Call user function every time
            </summary>
        </member>
        <member name="F:ImGuiNET.InputTextFlags.CallbackCharFilter">
            <summary>
            Call user function to filter character. Modify data->EventChar to replace/filter input, or return 1 to discard character.
            </summary>
        </member>
        <member name="F:ImGuiNET.InputTextFlags.AllowTabInput">
            <summary>
            Pressing TAB input a '\t' character into the text field
            </summary>
        </member>
        <member name="F:ImGuiNET.InputTextFlags.CtrlEnterForNewLine">
            <summary>
            In multi-line mode, allow exiting edition by pressing Enter. Ctrl+Enter to add new line (by default adds new lines with Enter).
            </summary>
        </member>
        <member name="F:ImGuiNET.InputTextFlags.NoHorizontalScroll">
            <summary>
            Disable following the cursor horizontally
            </summary>
        </member>
        <member name="F:ImGuiNET.InputTextFlags.AlwaysInsertMode">
            <summary>
            Insert mode
            </summary>
        </member>
        <member name="F:ImGuiNET.InputTextFlags.ReadOnly">
            <summary>
            Read-only mode
            </summary>
        </member>
        <member name="F:ImGuiNET.InputTextFlags.Password">
            <summary>
            Password mode, display all characters as '*'
            </summary>
        </member>
        <member name="F:ImGuiNET.InputTextFlags.NoUndoRedo">
            <summary>
            Disable undo/redo. Note that input text owns the text data while active, if you want to provide your own undo/redo stack you need e.g. to call ClearActiveID().
            </summary>
        </member>
        <member name="F:ImGuiNET.InputTextFlags.Multiline">
            <summary>
            For internal use by InputTextMultiline()
            </summary>
        </member>
        <member name="P:ImGuiNET.IO.DisplaySize">
            <summary>
            Display size, in pixels. For clamping windows positions.
            Default value: [unset]
            </summary>
        </member>
        <member name="P:ImGuiNET.IO.DeltaTime">
            <summary>
            Time elapsed since last frame, in seconds.
            Default value: 1.0f / 10.0f.
            </summary>
        </member>
        <member name="P:ImGuiNET.IO.DisplayFramebufferScale">
            <summary>
            For retina display or other situations where window coordinates are different from framebuffer coordinates.
            User storage only, presently not used by ImGui.
            Default value: (1.0f, 1.0f).
            </summary>
        </member>
        <member name="P:ImGuiNET.IO.MousePosition">
            <summary>
            Mouse position, in pixels (set to -1,-1 if no mouse / on another screen, etc.).
            </summary>
        </member>
        <member name="P:ImGuiNET.IO.MouseWheel">
            <summary>
            Mouse wheel: 1 unit scrolls about 5 lines text.
            </summary>
        </member>
        <member name="P:ImGuiNET.IO.MouseDown">
            <summary>
            Mouse buttons: left, right, middle + extras.
            ImGui itself mostly only uses left button (BeginPopupContext** are using right button).
            Others buttons allows us to track if the mouse is being used by your application + available to user as a convenience via IsMouse** API.
            </summary>
        </member>
        <member name="P:ImGuiNET.IO.KeyMap">
            <summary>
            Map of indices into the KeysDown[512] entries array.
            Default values: [unset]
            </summary>
        </member>
        <member name="P:ImGuiNET.IO.KeysDown">
            <summary>
            Keyboard keys that are pressed (in whatever storage order you naturally have access to keyboard data)
            </summary>
        </member>
        <member name="P:ImGuiNET.IO.CtrlPressed">
            <summary>
            Keyboard modifier pressed: Control.
            </summary>
        </member>
        <member name="P:ImGuiNET.IO.ShiftPressed">
            <summary>
            Keyboard modifier pressed: Shift
            </summary>
        </member>
        <member name="P:ImGuiNET.IO.AltPressed">
            <summary>
            Keyboard modifier pressed: Alt
            </summary>
        </member>
        <member name="P:ImGuiNET.IO.SuperPressed">
            <summary>
            Keyboard modifier pressed: Cmd/Super/Windows
            </summary>
        </member>
        <member name="T:ImGuiNET.MouseCursorKind">
            <summary>
            Enumeration for GetMouseCursor()
            </summary>
        </member>
        <member name="F:ImGuiNET.MouseCursorKind.TextInput">
            <summary>
            When hovering over InputText, etc.
            </summary>
        </member>
        <member name="F:ImGuiNET.MouseCursorKind.Move">
            <summary>
            Unused
            </summary>
        </member>
        <member name="F:ImGuiNET.MouseCursorKind.ResizeNS">
            <summary>
            Unused
            </summary>
        </member>
        <member name="F:ImGuiNET.MouseCursorKind.ResizeEW">
            <summary>
            When hovering over a column
            </summary>
        </member>
        <member name="F:ImGuiNET.MouseCursorKind.ResizeNESW">
            <summary>
            Unused
            </summary>
        </member>
        <member name="F:ImGuiNET.MouseCursorKind.ResizeNWSE">
            <summary>
            When hovering over the bottom-right corner of a window
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.DisplaySize">
            <summary>
            Display size, in pixels. For clamping windows positions.
            Default value: [unset]
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.DeltaTime">
            <summary>
            Time elapsed since last frame, in seconds.
            Default value: 1.0f / 10.0f.
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.IniSavingRate">
            <summary>
            Maximum time between saving positions/sizes to .ini file, in seconds.
            Default value: 5.0f.
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.IniFilename">
            <summary>
            Path to .ini file. NULL to disable .ini saving.
            Default value: "imgui.ini"
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.LogFilename">
            <summary>
            Path to .log file (default parameter to ImGui::LogToFile when no file is specified).
            Default value: "imgui_log.txt"
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.MouseDoubleClickTime">
            <summary>
            Time for a double-click, in seconds.
            Default value: 0.30f.
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.MouseDoubleClickMaxDist">
            <summary>
            Distance threshold to stay in to validate a double-click, in pixels.
            Default Value: 6.0f.
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.MouseDragThreshold">
            <summary>
            Distance threshold before considering we are dragging.
            Default Value: 6.0f.
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.KeyMap">
            <summary>
            Map of indices into the KeysDown[512] entries array.
            Default values: [unset]
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.KeyRepeatDelay">
            <summary>
            When holding a key/button, time before it starts repeating, in seconds. (for actions where 'repeat' is active).
            Default value: 0.250f.
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.KeyRepeatRate">
            <summary>
            When holding a key/button, rate at which it repeats, in seconds.
            Default value: 0.020f.
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.UserData">
            <summary>
            Store your own data for retrieval by callbacks.
            Default value: IntPtr.Zero.
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.FontAtlas">
            <summary>
            Load and assemble one or more fonts into a single tightly packed texture. Output to Fonts array.
            Default value: [auto]
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.FontGlobalScale">
            <summary>
            Global scale all fonts.
            Default value: 1.0f.
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.FontAllowUserScaling">
            <summary>
            Allow user scaling text of individual window with CTRL+Wheel.
            Default value: false.
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.FontDefault">
            <summary>
            Font to use on NewFrame(). Use NULL to uses Fonts->Fonts[0].
            Default value: null.
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.DisplayFramebufferScale">
            <summary>
            For retina display or other situations where window coordinates are different from framebuffer coordinates.
            User storage only, presently not used by ImGui.
            Default value: (1.0f, 1.0f).
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.DisplayVisibleMin">
            <summary>
            If you use DisplaySize as a virtual space larger than your screen, set DisplayVisibleMin/Max to the visible area.
            Default value: (0.0f, 0.0f)
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.DisplayVisibleMax">
            <summary>
            If the values are the same, we defaults to Min=0.0f) and Max=DisplaySize.
            Default value: (0.0f, 0.0f).
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.OptMacOSXBehaviors">
            <summary>
            OS X style: Text editing cursor movement using Alt instead of Ctrl,
            Shortcuts using Cmd/Super instead of Ctrl,
            Line/Text Start and End using Cmd+Arrows instead of Home/End,
            Double click selects by word instead of selecting whole text,
            Multi-selection in lists uses Cmd/Super instead of Ctrl
            Default value: True on OSX; false otherwise.
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.OptCursorBlink">
            <summary>
            Enable blinking cursor, for users who consider it annoying.
            Default value: true.
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.RenderDrawListsFn">
            <summary>
            Rendering function, will be called in Render(). 
            Alternatively you can keep this to NULL and call GetDrawData() after Render() to get the same pointer.
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.GetClipboardTextFn">
            <summary>
            Optional: access OS clipboard
            (default to use native Win32 clipboard on Windows, otherwise uses a private clipboard. Override to access OS clipboard on other architectures)
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.SetClipboardTextFn">
            <summary>
            Optional: access OS clipboard
            (default to use native Win32 clipboard on Windows, otherwise uses a private clipboard. Override to access OS clipboard on other architectures)
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.MemAllocFn">
            <summary>
            Optional: override memory allocations. MemFreeFn() may be called with a NULL pointer.
            (default to posix malloc/free)
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.MemFreeFn">
            <summary>
            Optional: override memory allocations. MemFreeFn() may be called with a NULL pointer.
            (default to posix malloc/free)
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.ImeSetInputScreenPosFn">
            <summary>
            Optional: notify OS Input Method Editor of the screen position of your cursor for text input position (e.g. when using Japanese/Chinese IME in Windows)
            (default to use native imm32 api on Windows)
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.ImeWindowHandle">
            <summary>
            (Windows) Set this to your HWND to get automatic IME cursor positioning.
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.MousePos">
            <summary>
            Mouse position, in pixels (set to -1,-1 if no mouse / on another screen, etc.).
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.MouseDown">
            <summary>
            Mouse buttons: left, right, middle + extras.
            ImGui itself mostly only uses left button (BeginPopupContext** are using right button).
            Others buttons allows us to track if the mouse is being used by your application + available to user as a convenience via IsMouse** API.
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.MouseWheel">
            <summary>
            Mouse wheel: 1 unit scrolls about 5 lines text.
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.MouseDrawCursor">
            <summary>
            Request ImGui to draw a mouse cursor for you (if you are on a platform without a mouse cursor).
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.KeyCtrl">
            <summary>
            Keyboard modifier pressed: Control.
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.KeyShift">
            <summary>
            Keyboard modifier pressed: Shift
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.KeyAlt">
            <summary>
            Keyboard modifier pressed: Alt
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.KeySuper">
            <summary>
            Keyboard modifier pressed: Cmd/Super/Windows
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.KeysDown">
            <summary>
            Keyboard keys that are pressed (in whatever storage order you naturally have access to keyboard data)
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.InputCharacters">
            <summary>
            List of characters input (translated by user from keypress+keyboard state).
            Fill using AddInputCharacter() helper.
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.WantCaptureMouse">
            <summary>
            Mouse is hovering a window or widget is active (= ImGui will use your mouse input).
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.WantCaptureKeyboard">
            <summary>
            Widget is active (= ImGui will use your keyboard input).
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.WantTextInput">
            <summary>
            Some text input widget is active, which will read input characters from the InputCharacters array.
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.WantMoveMouse">
            <summary>
            MousePos has been altered, back-end should reposition mouse on next frame. Set only when 'NavMovesMouse=true'.
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.Framerate">
            <summary>
            Framerate estimation, in frame per second. Rolling average estimation based on IO.DeltaTime over 120 frames.
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.MetricsAllocs">
            <summary>
            Number of active memory allocations.
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.MetricsRenderVertices">
            <summary>
            Vertices output during last call to Render().
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.MetricsRenderIndices">
            <summary>
            Indices output during last call to Render() = number of triangles * 3
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.MetricsActiveWindows">
            <summary>
            Number of visible windows (exclude child windows)
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.MouseDelta">
            <summary>
            Mouse delta. Note that this is zero if either current or previous position are negative,
            so a disappearing/reappearing mouse won't have a huge delta for one frame.
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.MousePosPrev">
            <summary>
            Previous mouse position
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.MouseClickedPos0">
            <summary>
            Position at time of clicking
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.MouseClickedPos1">
            <summary>
            Position at time of clicking
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.MouseClickedPos2">
            <summary>
            Position at time of clicking
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.MouseClickedPos3">
            <summary>
            Position at time of clicking
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.MouseClickedPos4">
            <summary>
            Position at time of clicking
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.MouseClickedTime">
            <summary>
            Time of last click (used to figure out double-click)
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.MouseClicked">
            <summary>
            Mouse button went from !Down to Down
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.MouseDoubleClicked">
            <summary>
            Has mouse button been double-clicked?
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.MouseReleased">
            <summary>
            Mouse button went from Down to !Down
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.MouseDownOwned">
            <summary>
            Track if button was clicked inside a window.
            We don't request mouse capture from the application if click started outside ImGui bounds.
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.MouseDownDuration">
            <summary>
            Duration the mouse button has been down (0.0f == just clicked).
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.MouseDownDurationPrev">
            <summary>
            Previous time the mouse button has been down
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.MouseDragMaxDistanceAbs0">
            <summary>
            Maximum distance, absolute, on each axis, of how much mouse has traveled from the clicking point
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.MouseDragMaxDistanceAbs1">
            <summary>
            Maximum distance, absolute, on each axis, of how much mouse has traveled from the clicking point
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.MouseDragMaxDistanceAbs2">
            <summary>
            Maximum distance, absolute, on each axis, of how much mouse has traveled from the clicking point
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.MouseDragMaxDistanceAbs3">
            <summary>
            Maximum distance, absolute, on each axis, of how much mouse has traveled from the clicking point
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.MouseDragMaxDistanceAbs4">
            <summary>
            Maximum distance, absolute, on each axis, of how much mouse has traveled from the clicking point
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.MouseDragMaxDistanceSqr">
            <summary>
            Squared maximum distance of how much mouse has traveled from the click point
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.KeysDownDuration">
            <summary>
            Duration the keyboard key has been down (0.0f == just pressed)
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeIO.KeysDownDurationPrev">
            <summary>
            Previous duration the key has been down
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeStyle.Alpha">
            <summary>
            Global alpha applies to everything in ImGui.
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeStyle.WindowPadding">
            <summary>
            Padding within a window.
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeStyle.WindowRounding">
            <summary>
            Radius of window corners rounding. Set to 0.0f to have rectangular windows.
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeStyle.WindowBorderSize">
            <summary>
            Thickness of border around windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly)
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeStyle.WindowMinSize">
            <summary>
            Minimum window size.
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeStyle.WindowTitleAlign">
            <summary>
            Alignment for title bar text.
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeStyle.ChildRounding">
            <summary>
            Radius of child window corners rounding. Set to 0.0f to have rectangular windows.
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeStyle.ChildBorderSize">
            <summary>
            Thickness of border around child windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly)
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeStyle.PopupRounding">
            <summary>
            Radius of popup window corners rounding.
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeStyle.PopupBorderSize">
            <summary>
            Thickness of border around popup windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly)
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeStyle.FramePadding">
            <summary>
            Padding within a framed rectangle (used by most widgets).
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeStyle.FrameRounding">
            <summary>
            Radius of frame corners rounding. Set to 0.0f to have rectangular frame (used by most widgets). 
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeStyle.FrameBorderSize">
            <summary>
            Thickness of border around frames. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly)
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeStyle.ItemSpacing">
            <summary>
            Horizontal and vertical spacing between widgets/lines.
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeStyle.ItemInnerSpacing">
            <summary>
            Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label).
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeStyle.TouchExtraPadding">
            <summary>
            Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeStyle.IndentSpacing">
            <summary>
            Horizontal indentation when e.g. entering a tree node
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeStyle.ColumnsMinSpacing">
            <summary>
            Minimum horizontal spacing between two columns
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeStyle.ScrollbarSize">
            <summary>
            Width of the vertical scrollbar, Height of the horizontal scrollbar
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeStyle.ScrollbarRounding">
            <summary>
            Radius of grab corners for scrollbar
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeStyle.GrabMinSize">
            <summary>
            Minimum width/height of a grab box for slider/scrollbar
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeStyle.GrabRounding">
            <summary>
            Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeStyle.ButtonTextAlign">
            <summary>
            Alignment of button text when button is larger than text. Defaults to (0.5f,0.5f) for horizontally+vertically centered.
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeStyle.DisplayWindowPadding">
            <summary>
            Window positions are clamped to be visible within the display area by at least this amount. Only covers regular windows.
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeStyle.DisplaySafeAreaPadding">
            <summary>
            If you cannot see the edge of your screen (e.g. on a TV) increase the safe area padding. Covers popups/tooltips as well regular windows.
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeStyle.AntiAliasedLines">
            <summary>
            Enable anti-aliasing on lines/borders. Disable if you are really tight on CPU/GPU.
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeStyle.AntiAliasedFill">
            <summary>
            Enable anti-aliasing on filled shapes (rounded rectangles, circles, etc.)
            </summary>
        </member>
        <member name="F:ImGuiNET.NativeStyle.CurveTessellationTol">
            <summary>
            Tessellation tolerance. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.
            </summary>
        </member>
        <member name="T:ImGuiNET.SelectableFlags">
            <summary>
            Flags for ImGui::Selectable()
            </summary>
        </member>
        <member name="F:ImGuiNET.SelectableFlags.DontClosePopups">
            <summary>
            Clicking this doesn't close parent popup window
            </summary>
        </member>
        <member name="F:ImGuiNET.SelectableFlags.SpanAllColumns">
            <summary>
            Selectable frame can span all columns (text will still fit in current column)
            </summary>
        </member>
        <member name="F:ImGuiNET.Storage.Data">
            <summary>
            A vector of Storage.Pair values.
            </summary>
        </member>
        <member name="P:ImGuiNET.Style.Alpha">
            <summary>
            Global alpha applies to everything in ImGui.
            </summary>
        </member>
        <member name="P:ImGuiNET.Style.WindowPadding">
            <summary>
            Padding within a window.
            </summary>
        </member>
        <member name="P:ImGuiNET.Style.WindowMinSize">
            <summary>
            Minimum window size.
            </summary>
        </member>
        <member name="P:ImGuiNET.Style.WindowRounding">
            <summary>
            Radius of window corners rounding. Set to 0.0f to have rectangular windows.
            </summary>
        </member>
        <member name="P:ImGuiNET.Style.WindowTitleAlign">
            <summary>
            Alignment for title bar text.
            </summary>
        </member>
        <member name="P:ImGuiNET.Style.ChildWindowRounding">
            <summary>
            Radius of child window corners rounding. Set to 0.0f to have rectangular windows.
            </summary>
        </member>
        <member name="P:ImGuiNET.Style.FramePadding">
            <summary>
            Padding within a framed rectangle (used by most widgets).
            </summary>
        </member>
        <member name="P:ImGuiNET.Style.FrameRounding">
            <summary>
            Radius of frame corners rounding. Set to 0.0f to have rectangular frame (used by most widgets). 
            </summary>
        </member>
        <member name="P:ImGuiNET.Style.ItemSpacing">
            <summary>
            Horizontal and vertical spacing between widgets/lines.
            </summary>
        </member>
        <member name="P:ImGuiNET.Style.ItemInnerSpacing">
            <summary>
            Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label).
            </summary>
        </member>
        <member name="P:ImGuiNET.Style.TouchExtraPadding">
            <summary>
            Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!
            </summary>
        </member>
        <member name="P:ImGuiNET.Style.IndentSpacing">
            <summary>
            Horizontal indentation when e.g. entering a tree node
            </summary>
        </member>
        <member name="P:ImGuiNET.Style.ColumnsMinSpacing">
            <summary>
            Minimum horizontal spacing between two columns
            </summary>
        </member>
        <member name="P:ImGuiNET.Style.ScrollbarSize">
            <summary>
            Width of the vertical scrollbar, Height of the horizontal scrollbar
            </summary>
        </member>
        <member name="P:ImGuiNET.Style.ScrollbarRounding">
            <summary>
            Radius of grab corners for scrollbar
            </summary>
        </member>
        <member name="P:ImGuiNET.Style.GrabMinSize">
            <summary>
            Minimum width/height of a grab box for slider/scrollbar
            </summary>
        </member>
        <member name="P:ImGuiNET.Style.GrabRounding">
            <summary>
            Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.
            </summary>
        </member>
        <member name="P:ImGuiNET.Style.DisplayWindowPadding">
            <summary>
            Window positions are clamped to be visible within the display area by at least this amount. Only covers regular windows.
            </summary>
        </member>
        <member name="P:ImGuiNET.Style.DisplaySafeAreaPadding">
            <summary>
            If you cannot see the edge of your screen (e.g. on a TV) increase the safe area padding. Covers popups/tooltips as well regular windows.
            </summary>
        </member>
        <member name="P:ImGuiNET.Style.AntiAliasedLines">
            <summary>
            Enable anti-aliasing on lines/borders. Disable if you are really tight on CPU/GPU.
            </summary>
        </member>
        <member name="P:ImGuiNET.Style.AntiAliasedFill">
            <summary>
            Enable anti-aliasing on filled shapes (rounded rectangles, circles, etc.)
            </summary>
        </member>
        <member name="P:ImGuiNET.Style.CurveTessellationTolerance">
            <summary>
            Tessellation tolerance. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.
            </summary>
        </member>
        <member name="M:ImGuiNET.Style.GetColor(ImGuiNET.ColorTarget)">
            <summary>
            Gets the current style color for the given UI element type.
            </summary>
            <param name="target">The type of UI element.</param>
            <returns>The element's color as currently configured.</returns>
        </member>
        <member name="M:ImGuiNET.Style.SetColor(ImGuiNET.ColorTarget,Glaives.Core.Graphics.Color)">
            <summary>
            Sets the style color for a particular UI element type.
            </summary>
            <param name="target">The type of UI element.</param>
            <param name="value">The new color.</param>
        </member>
        <member name="T:ImGuiNET.StyleVar">
            <summary>
            Enumeration for PushStyleVar() / PopStyleVar()
            NB: the enum only refers to fields of ImGuiStyle() which makes sense to be pushed/poped in UI code. Feel free to add others.
            </summary>
        </member>
        <member name="F:ImGuiNET.StyleVar.Alpha">
            <summary>
            float
            </summary>
        </member>
        <member name="F:ImGuiNET.StyleVar.WindowPadding">
            <summary>
            System.Numerics.Vector2
            </summary>
        </member>
        <member name="F:ImGuiNET.StyleVar.WindowRounding">
            <summary>
            float
            </summary>
        </member>
        <member name="F:ImGuiNET.StyleVar.WindowBorderSize">
            <summary>
            float
            </summary>
        </member>
        <member name="F:ImGuiNET.StyleVar.WindowMinSize">
            <summary>
            System.Numerics.Vector2
            </summary>
        </member>
        <member name="F:ImGuiNET.StyleVar.ChildRounding">
            <summary>
            float
            </summary>
        </member>
        <member name="F:ImGuiNET.StyleVar.ChildBorderSize">
            <summary>
            float
            </summary>
        </member>
        <member name="F:ImGuiNET.StyleVar.PopupRounding">
            <summary>
            float
            </summary>
        </member>
        <member name="F:ImGuiNET.StyleVar.PopupBorderSize">
            <summary>
            float
            </summary>
        </member>
        <member name="F:ImGuiNET.StyleVar.FramePadding">
            <summary>
            System.Numerics.Vector2
            </summary>
        </member>
        <member name="F:ImGuiNET.StyleVar.FrameRounding">
            <summary>
            float
            </summary>
        </member>
        <member name="F:ImGuiNET.StyleVar.FrameBorderSize">
            <summary>
            float
            </summary>
        </member>
        <member name="F:ImGuiNET.StyleVar.ItemSpacing">
            <summary>
            System.Numerics.Vector2
            </summary>
        </member>
        <member name="F:ImGuiNET.StyleVar.ItemInnerSpacing">
            <summary>
            System.Numerics.Vector2
            </summary>
        </member>
        <member name="F:ImGuiNET.StyleVar.IndentSpacing">
            <summary>
            float
            </summary>
        </member>
        <member name="F:ImGuiNET.StyleVar.GrabMinSize">
            <summary>
            float
            </summary>
        </member>
        <member name="F:ImGuiNET.StyleVar.ButtonTextAlign">
            <summary>
            System.Numerics.Vector2
            </summary>
        </member>
        <member name="F:ImGuiNET.TextEditCallbackData.EventFlag">
            <summary>
            One of InputTextFlags.*. Read-only.
            </summary>
        </member>
        <member name="F:ImGuiNET.TextEditCallbackData.Flags">
            <summary>
            What user passed to InputText(). Read-only.
            </summary>
        </member>
        <member name="F:ImGuiNET.TextEditCallbackData.UserData">
            <summary>
            What user passed to InputText(). Read-only.
            </summary>
        </member>
        <member name="P:ImGuiNET.TextEditCallbackData.ReadOnly">
            <summary>
            Read-only mode. Read-only.
            </summary>
        </member>
        <member name="F:ImGuiNET.TextEditCallbackData.EventChar">
            <summary>
            Character input. Read-write (replace character or set to zero).
            </summary>
        </member>
        <member name="F:ImGuiNET.TextEditCallbackData.EventKey">
            <summary>
            Key pressed (Up/Down/Tab). Read-only.
            </summary>
        </member>
        <member name="F:ImGuiNET.TextEditCallbackData.Buf">
            <summary>
            Current text. Read-write (pointed data only). char* in native code.
            </summary>
        </member>
        <member name="F:ImGuiNET.TextEditCallbackData.BufSize">
            <summary>
            Read-only.
            </summary>
        </member>
        <member name="F:ImGuiNET.TextEditCallbackData.BufDirty">
            <summary>
            Must set if you modify Buf directly. Write-only.
            </summary>
        </member>
        <member name="F:ImGuiNET.TextEditCallbackData.CursorPos">
            <summary>
            Read-write.
            </summary>
        </member>
        <member name="F:ImGuiNET.TextEditCallbackData.SelectionStart">
            <summary>
            Read-write. (Equal to SelectionEnd when no selection)
            </summary>
        </member>
        <member name="F:ImGuiNET.TextEditCallbackData.SelectionEnd">
            <summary>
            Read-write.
            </summary>
        </member>
        <member name="F:ImGuiNET.TreeNodeFlags.Selected">
            <summary>
            Draw as selected
            </summary>
        </member>
        <member name="F:ImGuiNET.TreeNodeFlags.Framed">
            <summary>
            Full colored frame (e.g. for CollapsingHeader)
            </summary>
        </member>
        <member name="F:ImGuiNET.TreeNodeFlags.AllowItemOverlap">
            <summary>
            Hit testing to allow subsequent widgets to overlap this one
            </summary>
        </member>
        <member name="F:ImGuiNET.TreeNodeFlags.NoTreePushOnOpen">
            <summary>
            Don't do a TreePush() when open (e.g. for CollapsingHeader) = no extra indent nor pushing on ID stack
            </summary>
        </member>
        <member name="F:ImGuiNET.TreeNodeFlags.NoAutoOpenOnLog">
            <summary>
            Don't automatically and temporarily open node when Logging is active (by default logging will automatically open tree nodes)
            </summary>
        </member>
        <member name="F:ImGuiNET.TreeNodeFlags.DefaultOpen">
            <summary>
            Default node to be open
            </summary>
        </member>
        <member name="F:ImGuiNET.TreeNodeFlags.OpenOnDoubleClick">
            <summary>
            Need double-click to open node
            </summary>
        </member>
        <member name="F:ImGuiNET.TreeNodeFlags.OpenOnArrow">
            <summary>
            Only open when clicking on the arrow part. If ImGuiTreeNodeFlags_OpenOnDoubleClick is also set, single-click arrow or double-click all box to open.
            </summary>
        </member>
        <member name="F:ImGuiNET.TreeNodeFlags.Leaf">
            <summary>
            No collapsing, no arrow (use as a convenience for leaf nodes).
            </summary>
        </member>
        <member name="F:ImGuiNET.TreeNodeFlags.Bullet">
            <summary>
            Display a bullet instead of arrow
            </summary>
        </member>
        <member name="F:ImGuiNET.TreeNodeFlags.FramePadding">
            <summary>
            Use FramePadding (even for an unframed text node) to vertically align text baseline
            </summary>
        </member>
        <member name="T:ImGuiNET.WindowFlags">
            <summary>
            Flags for ImGui::Begin()
            </summary>
        </member>
        <member name="F:ImGuiNET.WindowFlags.NoTitleBar">
            <summary>
            Disable title-bar
            </summary>
        </member>
        <member name="F:ImGuiNET.WindowFlags.NoResize">
            <summary>
            Disable user resizing with the lower-right grip
            </summary>
        </member>
        <member name="F:ImGuiNET.WindowFlags.NoMove">
            <summary>
            Disable user moving the window
            </summary>
        </member>
        <member name="F:ImGuiNET.WindowFlags.NoScrollbar">
            <summary>
            Disable scrollbar (window can still scroll with mouse or programatically)
            </summary>
        </member>
        <member name="F:ImGuiNET.WindowFlags.NoScrollWithMouse">
            <summary>
            Disable user scrolling with mouse wheel
            </summary>
        </member>
        <member name="F:ImGuiNET.WindowFlags.NoCollapse">
            <summary>
            Disable user collapsing window by double-clicking on it
            </summary>
        </member>
        <member name="F:ImGuiNET.WindowFlags.AlwaysAutoResize">
            <summary>
            Resize every window to its content every frame
            </summary>
        </member>
        <member name="F:ImGuiNET.WindowFlags.NoSavedSettings">
            <summary>
            Never load/save settings in .ini file
            </summary>
        </member>
        <member name="F:ImGuiNET.WindowFlags.NoInputs">
            <summary>
            Disable catching mouse or keyboard inputs
            </summary>
        </member>
        <member name="F:ImGuiNET.WindowFlags.MenuBar">
            <summary>
            Has a menu-bar
            </summary>
        </member>
        <member name="F:ImGuiNET.WindowFlags.HorizontalScrollbar">
            <summary>
            Enable horizontal scrollbar (off by default).
            You need to use SetNextWindowContentSize(ImVec2(width,0.0f)); prior to calling Begin() to specify width.
            </summary>
        </member>
        <member name="F:ImGuiNET.WindowFlags.NoFocusOnAppearing">
            <summary>
            Disable taking focus when transitioning from hidden to visible state
            </summary>
        </member>
        <member name="F:ImGuiNET.WindowFlags.NoBringToFrontOnFocus">
            <summary>
            Disable bringing window to front when taking focus (e.g. clicking on it or programatically giving it focus)
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:ImGuiNET.WindowFlags.AlwaysVerticalScrollbar" -->
        <!-- Badly formed XML comment ignored for member "F:ImGuiNET.WindowFlags.AlwaysHorizontalScrollbar" -->
        <member name="F:ImGuiNET.WindowFlags.AlwaysUseWindowPadding">
            <summary>
            Ensure child windows without border uses style.WindowPadding (ignored by default for non-bordered child windows, because more convenient)
            </summary>
        </member>
        <member name="F:ImGuiNET.WindowFlags.ResizeFromAnySide">
            <summary>
            Enable resize from any corners and borders. Your back-end needs to honor the different values of io.MouseCursor set by imgui.
            </summary>
        </member>
        <member name="M:SDL2.SDL.SDL_GetNumTouchDevices">
            \brief Get the number of registered touch devices.
        </member>
        <member name="M:SDL2.SDL.SDL_GetTouchDevice(System.Int32)">
            \brief Get the touch ID with the given index, or 0 if the index is invalid.
        </member>
        <member name="M:SDL2.SDL.SDL_GetNumTouchFingers(System.Int64)">
            \brief Get the number of active fingers for a given touch device.
        </member>
        <member name="M:SDL2.SDL.SDL_GetTouchFinger(System.Int64,System.Int32)">
            \brief Get the finger object of the given touch, with the given index.
            Returns pointer to SDL_Finger.
        </member>
    </members>
</doc>
